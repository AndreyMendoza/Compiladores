Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    Inf
    NaN
    NA

Grammar

Rule 0     S' -> prog
Rule 1     prog -> exprlist
Rule 2     emptyline -> NLINE
Rule 3     emptyline -> emptyline NLINE
Rule 4     exprlist -> empty
Rule 5     exprlist -> expr_or_assign
Rule 6     exprlist -> exprlist ;
Rule 7     exprlist -> exprlist emptyline
Rule 8     exprlist -> exprlist ; expr_or_assign
Rule 9     exprlist -> exprlist emptyline expr_or_assign
Rule 10    expr_or_assign -> expr
Rule 11    expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign
Rule 12    expr_or_assign_nl -> expr_or_assign
Rule 13    expr_or_assign_nl -> emptyline expr_or_assign
Rule 14    expr -> const_or_symbol
Rule 15    expr -> binary_operation
Rule 16    expr -> unary_operation
Rule 17    expr -> statement_declaration
Rule 18    expr -> expr RIGHT_ASSIGN SYMBOL
Rule 19    expr -> SYMBOL LEFT_ASSIGN expr
Rule 20    expr -> ( expr_or_assign )
Rule 21    expr -> expr [ sublist ]
Rule 22    expr -> expr LBB sublist ] ]
Rule 23    expr -> { exprlist }
Rule 24    expr -> FUNCTION ( formlist ) expr_or_assign_nl
Rule 25    expr -> SYMBOL ( sublist )
Rule 26    formlist -> SYMBOL
Rule 27    formlist -> SYMBOL EQ_ASSIGN expr
Rule 28    formlist -> formlist , SYMBOL
Rule 29    formlist -> formlist , SYMBOL EQ_ASSIGN expr
Rule 30    formlist -> empty
Rule 31    sublist -> sub
Rule 32    sublist -> sublist , sub
Rule 33    sub -> empty
Rule 34    sub -> expr
Rule 35    const_or_symbol -> SYMBOL
Rule 36    const_or_symbol -> STR_CONST
Rule 37    const_or_symbol -> REAL
Rule 38    const_or_symbol -> INT
Rule 39    const_or_symbol -> NULL_CONST
Rule 40    const_or_symbol -> TRUE
Rule 41    const_or_symbol -> FALSE
Rule 42    binary_operation -> expr + expr
Rule 43    binary_operation -> expr - expr
Rule 44    binary_operation -> expr * expr
Rule 45    binary_operation -> expr POWER expr
Rule 46    binary_operation -> expr MOD expr
Rule 47    binary_operation -> expr INT_DIV expr
Rule 48    binary_operation -> expr / expr
Rule 49    binary_operation -> expr : expr
Rule 50    binary_operation -> expr ~ expr
Rule 51    binary_operation -> expr ? expr
Rule 52    binary_operation -> expr LT expr
Rule 53    binary_operation -> expr LE expr
Rule 54    binary_operation -> expr EQ expr
Rule 55    binary_operation -> expr NE expr
Rule 56    binary_operation -> expr GE expr
Rule 57    binary_operation -> expr GT expr
Rule 58    binary_operation -> expr AND expr
Rule 59    binary_operation -> expr OR expr
Rule 60    binary_operation -> expr AND2 expr
Rule 61    binary_operation -> expr OR2 expr
Rule 62    binary_operation -> expr MATRIX_MULT expr
Rule 63    binary_operation -> expr $ SYMBOL
Rule 64    binary_operation -> expr $ STR_CONST
Rule 65    binary_operation -> expr @ SYMBOL
Rule 66    binary_operation -> expr @ STR_CONST
Rule 67    unary_operation -> - expr
Rule 68    unary_operation -> + expr
Rule 69    unary_operation -> ! expr
Rule 70    unary_operation -> ~ expr
Rule 71    unary_operation -> ? expr
Rule 72    statement_declaration -> if_statement
Rule 73    statement_declaration -> for_statement
Rule 74    statement_declaration -> while_statement
Rule 75    if_statement -> IF ( expr ) expr_or_assign_nl else_statement
Rule 76    else_statement -> empty
Rule 77    else_statement -> ELSE expr_or_assign_nl
Rule 78    else_statement -> NLINE else_statement
Rule 79    for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl
Rule 80    while_statement -> WHILE ( expr ) expr_or_assign_nl
Rule 81    empty -> <empty>

Terminals, with rules where they appear

!                    : 69
$                    : 63 64
(                    : 20 24 25 75 79 80
)                    : 20 24 25 75 79 80
*                    : 44
+                    : 42 68
,                    : 28 29 32
-                    : 43 67
/                    : 48
:                    : 49
;                    : 6 8
?                    : 51 71
@                    : 65 66
AND                  : 58
AND2                 : 60
COMMENT              : 
ELSE                 : 77
EQ                   : 54
EQ_ASSIGN            : 11 27 29
FALSE                : 41
FOR                  : 79
FUNCTION             : 24
GE                   : 56
GT                   : 57
IF                   : 75
IN                   : 79
INT                  : 38
INT_DIV              : 47
Inf                  : 
LBB                  : 22
LE                   : 53
LEFT_ASSIGN          : 19
LT                   : 52
MATRIX_MULT          : 62
MOD                  : 46
NA                   : 
NE                   : 55
NLINE                : 2 3 78
NULL_CONST           : 39
NaN                  : 
OR                   : 59
OR2                  : 61
POWER                : 45
REAL                 : 37
RIGHT_ASSIGN         : 18
STR_CONST            : 36 64 66
SYMBOL               : 11 18 19 25 26 27 28 29 35 63 65 79
TRUE                 : 40
WHILE                : 80
[                    : 21
]                    : 21 22 22
error                : 
{                    : 23
}                    : 23
~                    : 50 70

Nonterminals, with rules where they appear

binary_operation     : 15
const_or_symbol      : 14
else_statement       : 75 78
empty                : 4 30 33 76
emptyline            : 3 7 9 13
expr                 : 10 18 19 21 22 27 29 34 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 64 65 66 67 68 69 70 71 75 79 80
expr_or_assign       : 5 8 9 11 12 13 20
expr_or_assign_nl    : 24 75 77 79 80
exprlist             : 1 6 7 8 9 23
for_statement        : 73
formlist             : 24 28 29
if_statement         : 72
prog                 : 0
statement_declaration : 17
sub                  : 31 32
sublist              : 21 22 25 32
unary_operation      : 16
while_statement      : 74

Parsing method: LALR

state 0

    (0) S' -> . prog
    (1) prog -> . exprlist
    (4) exprlist -> . empty
    (5) exprlist -> . expr_or_assign
    (6) exprlist -> . exprlist ;
    (7) exprlist -> . exprlist emptyline
    (8) exprlist -> . exprlist ; expr_or_assign
    (9) exprlist -> . exprlist emptyline expr_or_assign
    (81) empty -> .
    (10) expr_or_assign -> . expr
    (11) expr_or_assign -> . SYMBOL EQ_ASSIGN expr_or_assign
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    ;               reduce using rule 81 (empty -> .)
    NLINE           reduce using rule 81 (empty -> .)
    $end            reduce using rule 81 (empty -> .)
    SYMBOL          shift and go to state 6
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    prog                           shift and go to state 1
    exprlist                       shift and go to state 2
    empty                          shift and go to state 3
    expr_or_assign                 shift and go to state 4
    expr                           shift and go to state 5
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 1

    (0) S' -> prog .



state 2

    (1) prog -> exprlist .
    (6) exprlist -> exprlist . ;
    (7) exprlist -> exprlist . emptyline
    (8) exprlist -> exprlist . ; expr_or_assign
    (9) exprlist -> exprlist . emptyline expr_or_assign
    (2) emptyline -> . NLINE
    (3) emptyline -> . emptyline NLINE

    $end            reduce using rule 1 (prog -> exprlist .)
    ;               shift and go to state 31
    NLINE           shift and go to state 33

    emptyline                      shift and go to state 32

state 3

    (4) exprlist -> empty .

    ;               reduce using rule 4 (exprlist -> empty .)
    NLINE           reduce using rule 4 (exprlist -> empty .)
    $end            reduce using rule 4 (exprlist -> empty .)
    }               reduce using rule 4 (exprlist -> empty .)


state 4

    (5) exprlist -> expr_or_assign .

    ;               reduce using rule 5 (exprlist -> expr_or_assign .)
    NLINE           reduce using rule 5 (exprlist -> expr_or_assign .)
    $end            reduce using rule 5 (exprlist -> expr_or_assign .)
    }               reduce using rule 5 (exprlist -> expr_or_assign .)


state 5

    (10) expr_or_assign -> expr .
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

  ! shift/reduce conflict for RIGHT_ASSIGN resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for LBB resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for INT_DIV resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for : resolved as shift
  ! shift/reduce conflict for ~ resolved as shift
  ! shift/reduce conflict for ? resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND2 resolved as shift
  ! shift/reduce conflict for OR2 resolved as shift
  ! shift/reduce conflict for MATRIX_MULT resolved as shift
  ! shift/reduce conflict for $ resolved as shift
  ! shift/reduce conflict for @ resolved as shift
    ;               reduce using rule 10 (expr_or_assign -> expr .)
    NLINE           reduce using rule 10 (expr_or_assign -> expr .)
    $end            reduce using rule 10 (expr_or_assign -> expr .)
    )               reduce using rule 10 (expr_or_assign -> expr .)
    }               reduce using rule 10 (expr_or_assign -> expr .)
    ]               reduce using rule 10 (expr_or_assign -> expr .)
    ,               reduce using rule 10 (expr_or_assign -> expr .)
    ELSE            reduce using rule 10 (expr_or_assign -> expr .)
    RIGHT_ASSIGN    shift and go to state 34
    [               shift and go to state 35
    LBB             shift and go to state 36
    +               shift and go to state 37
    -               shift and go to state 38
    *               shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 41
    INT_DIV         shift and go to state 42
    /               shift and go to state 43
    :               shift and go to state 44
    ~               shift and go to state 45
    ?               shift and go to state 46
    LT              shift and go to state 47
    LE              shift and go to state 48
    EQ              shift and go to state 49
    NE              shift and go to state 50
    GE              shift and go to state 51
    GT              shift and go to state 52
    AND             shift and go to state 53
    OR              shift and go to state 54
    AND2            shift and go to state 55
    OR2             shift and go to state 56
    MATRIX_MULT     shift and go to state 57
    $               shift and go to state 58
    @               shift and go to state 59

  ! RIGHT_ASSIGN    [ reduce using rule 10 (expr_or_assign -> expr .) ]
  ! [               [ reduce using rule 10 (expr_or_assign -> expr .) ]
  ! LBB             [ reduce using rule 10 (expr_or_assign -> expr .) ]
  ! +               [ reduce using rule 10 (expr_or_assign -> expr .) ]
  ! -               [ reduce using rule 10 (expr_or_assign -> expr .) ]
  ! *               [ reduce using rule 10 (expr_or_assign -> expr .) ]
  ! POWER           [ reduce using rule 10 (expr_or_assign -> expr .) ]
  ! MOD             [ reduce using rule 10 (expr_or_assign -> expr .) ]
  ! INT_DIV         [ reduce using rule 10 (expr_or_assign -> expr .) ]
  ! /               [ reduce using rule 10 (expr_or_assign -> expr .) ]
  ! :               [ reduce using rule 10 (expr_or_assign -> expr .) ]
  ! ~               [ reduce using rule 10 (expr_or_assign -> expr .) ]
  ! ?               [ reduce using rule 10 (expr_or_assign -> expr .) ]
  ! LT              [ reduce using rule 10 (expr_or_assign -> expr .) ]
  ! LE              [ reduce using rule 10 (expr_or_assign -> expr .) ]
  ! EQ              [ reduce using rule 10 (expr_or_assign -> expr .) ]
  ! NE              [ reduce using rule 10 (expr_or_assign -> expr .) ]
  ! GE              [ reduce using rule 10 (expr_or_assign -> expr .) ]
  ! GT              [ reduce using rule 10 (expr_or_assign -> expr .) ]
  ! AND             [ reduce using rule 10 (expr_or_assign -> expr .) ]
  ! OR              [ reduce using rule 10 (expr_or_assign -> expr .) ]
  ! AND2            [ reduce using rule 10 (expr_or_assign -> expr .) ]
  ! OR2             [ reduce using rule 10 (expr_or_assign -> expr .) ]
  ! MATRIX_MULT     [ reduce using rule 10 (expr_or_assign -> expr .) ]
  ! $               [ reduce using rule 10 (expr_or_assign -> expr .) ]
  ! @               [ reduce using rule 10 (expr_or_assign -> expr .) ]


state 6

    (11) expr_or_assign -> SYMBOL . EQ_ASSIGN expr_or_assign
    (19) expr -> SYMBOL . LEFT_ASSIGN expr
    (25) expr -> SYMBOL . ( sublist )
    (35) const_or_symbol -> SYMBOL .

    EQ_ASSIGN       shift and go to state 60
    LEFT_ASSIGN     shift and go to state 61
    (               shift and go to state 62
    RIGHT_ASSIGN    reduce using rule 35 (const_or_symbol -> SYMBOL .)
    [               reduce using rule 35 (const_or_symbol -> SYMBOL .)
    LBB             reduce using rule 35 (const_or_symbol -> SYMBOL .)
    +               reduce using rule 35 (const_or_symbol -> SYMBOL .)
    -               reduce using rule 35 (const_or_symbol -> SYMBOL .)
    *               reduce using rule 35 (const_or_symbol -> SYMBOL .)
    POWER           reduce using rule 35 (const_or_symbol -> SYMBOL .)
    MOD             reduce using rule 35 (const_or_symbol -> SYMBOL .)
    INT_DIV         reduce using rule 35 (const_or_symbol -> SYMBOL .)
    /               reduce using rule 35 (const_or_symbol -> SYMBOL .)
    :               reduce using rule 35 (const_or_symbol -> SYMBOL .)
    ~               reduce using rule 35 (const_or_symbol -> SYMBOL .)
    ?               reduce using rule 35 (const_or_symbol -> SYMBOL .)
    LT              reduce using rule 35 (const_or_symbol -> SYMBOL .)
    LE              reduce using rule 35 (const_or_symbol -> SYMBOL .)
    EQ              reduce using rule 35 (const_or_symbol -> SYMBOL .)
    NE              reduce using rule 35 (const_or_symbol -> SYMBOL .)
    GE              reduce using rule 35 (const_or_symbol -> SYMBOL .)
    GT              reduce using rule 35 (const_or_symbol -> SYMBOL .)
    AND             reduce using rule 35 (const_or_symbol -> SYMBOL .)
    OR              reduce using rule 35 (const_or_symbol -> SYMBOL .)
    AND2            reduce using rule 35 (const_or_symbol -> SYMBOL .)
    OR2             reduce using rule 35 (const_or_symbol -> SYMBOL .)
    MATRIX_MULT     reduce using rule 35 (const_or_symbol -> SYMBOL .)
    $               reduce using rule 35 (const_or_symbol -> SYMBOL .)
    @               reduce using rule 35 (const_or_symbol -> SYMBOL .)
    ;               reduce using rule 35 (const_or_symbol -> SYMBOL .)
    NLINE           reduce using rule 35 (const_or_symbol -> SYMBOL .)
    $end            reduce using rule 35 (const_or_symbol -> SYMBOL .)
    )               reduce using rule 35 (const_or_symbol -> SYMBOL .)
    }               reduce using rule 35 (const_or_symbol -> SYMBOL .)
    ]               reduce using rule 35 (const_or_symbol -> SYMBOL .)
    ,               reduce using rule 35 (const_or_symbol -> SYMBOL .)
    ELSE            reduce using rule 35 (const_or_symbol -> SYMBOL .)


state 7

    (14) expr -> const_or_symbol .

    RIGHT_ASSIGN    reduce using rule 14 (expr -> const_or_symbol .)
    [               reduce using rule 14 (expr -> const_or_symbol .)
    LBB             reduce using rule 14 (expr -> const_or_symbol .)
    +               reduce using rule 14 (expr -> const_or_symbol .)
    -               reduce using rule 14 (expr -> const_or_symbol .)
    *               reduce using rule 14 (expr -> const_or_symbol .)
    POWER           reduce using rule 14 (expr -> const_or_symbol .)
    MOD             reduce using rule 14 (expr -> const_or_symbol .)
    INT_DIV         reduce using rule 14 (expr -> const_or_symbol .)
    /               reduce using rule 14 (expr -> const_or_symbol .)
    :               reduce using rule 14 (expr -> const_or_symbol .)
    ~               reduce using rule 14 (expr -> const_or_symbol .)
    ?               reduce using rule 14 (expr -> const_or_symbol .)
    LT              reduce using rule 14 (expr -> const_or_symbol .)
    LE              reduce using rule 14 (expr -> const_or_symbol .)
    EQ              reduce using rule 14 (expr -> const_or_symbol .)
    NE              reduce using rule 14 (expr -> const_or_symbol .)
    GE              reduce using rule 14 (expr -> const_or_symbol .)
    GT              reduce using rule 14 (expr -> const_or_symbol .)
    AND             reduce using rule 14 (expr -> const_or_symbol .)
    OR              reduce using rule 14 (expr -> const_or_symbol .)
    AND2            reduce using rule 14 (expr -> const_or_symbol .)
    OR2             reduce using rule 14 (expr -> const_or_symbol .)
    MATRIX_MULT     reduce using rule 14 (expr -> const_or_symbol .)
    $               reduce using rule 14 (expr -> const_or_symbol .)
    @               reduce using rule 14 (expr -> const_or_symbol .)
    ;               reduce using rule 14 (expr -> const_or_symbol .)
    NLINE           reduce using rule 14 (expr -> const_or_symbol .)
    $end            reduce using rule 14 (expr -> const_or_symbol .)
    )               reduce using rule 14 (expr -> const_or_symbol .)
    }               reduce using rule 14 (expr -> const_or_symbol .)
    ]               reduce using rule 14 (expr -> const_or_symbol .)
    ,               reduce using rule 14 (expr -> const_or_symbol .)
    ELSE            reduce using rule 14 (expr -> const_or_symbol .)


state 8

    (15) expr -> binary_operation .

    RIGHT_ASSIGN    reduce using rule 15 (expr -> binary_operation .)
    [               reduce using rule 15 (expr -> binary_operation .)
    LBB             reduce using rule 15 (expr -> binary_operation .)
    +               reduce using rule 15 (expr -> binary_operation .)
    -               reduce using rule 15 (expr -> binary_operation .)
    *               reduce using rule 15 (expr -> binary_operation .)
    POWER           reduce using rule 15 (expr -> binary_operation .)
    MOD             reduce using rule 15 (expr -> binary_operation .)
    INT_DIV         reduce using rule 15 (expr -> binary_operation .)
    /               reduce using rule 15 (expr -> binary_operation .)
    :               reduce using rule 15 (expr -> binary_operation .)
    ~               reduce using rule 15 (expr -> binary_operation .)
    ?               reduce using rule 15 (expr -> binary_operation .)
    LT              reduce using rule 15 (expr -> binary_operation .)
    LE              reduce using rule 15 (expr -> binary_operation .)
    EQ              reduce using rule 15 (expr -> binary_operation .)
    NE              reduce using rule 15 (expr -> binary_operation .)
    GE              reduce using rule 15 (expr -> binary_operation .)
    GT              reduce using rule 15 (expr -> binary_operation .)
    AND             reduce using rule 15 (expr -> binary_operation .)
    OR              reduce using rule 15 (expr -> binary_operation .)
    AND2            reduce using rule 15 (expr -> binary_operation .)
    OR2             reduce using rule 15 (expr -> binary_operation .)
    MATRIX_MULT     reduce using rule 15 (expr -> binary_operation .)
    $               reduce using rule 15 (expr -> binary_operation .)
    @               reduce using rule 15 (expr -> binary_operation .)
    ;               reduce using rule 15 (expr -> binary_operation .)
    NLINE           reduce using rule 15 (expr -> binary_operation .)
    $end            reduce using rule 15 (expr -> binary_operation .)
    )               reduce using rule 15 (expr -> binary_operation .)
    }               reduce using rule 15 (expr -> binary_operation .)
    ]               reduce using rule 15 (expr -> binary_operation .)
    ,               reduce using rule 15 (expr -> binary_operation .)
    ELSE            reduce using rule 15 (expr -> binary_operation .)


state 9

    (16) expr -> unary_operation .

    RIGHT_ASSIGN    reduce using rule 16 (expr -> unary_operation .)
    [               reduce using rule 16 (expr -> unary_operation .)
    LBB             reduce using rule 16 (expr -> unary_operation .)
    +               reduce using rule 16 (expr -> unary_operation .)
    -               reduce using rule 16 (expr -> unary_operation .)
    *               reduce using rule 16 (expr -> unary_operation .)
    POWER           reduce using rule 16 (expr -> unary_operation .)
    MOD             reduce using rule 16 (expr -> unary_operation .)
    INT_DIV         reduce using rule 16 (expr -> unary_operation .)
    /               reduce using rule 16 (expr -> unary_operation .)
    :               reduce using rule 16 (expr -> unary_operation .)
    ~               reduce using rule 16 (expr -> unary_operation .)
    ?               reduce using rule 16 (expr -> unary_operation .)
    LT              reduce using rule 16 (expr -> unary_operation .)
    LE              reduce using rule 16 (expr -> unary_operation .)
    EQ              reduce using rule 16 (expr -> unary_operation .)
    NE              reduce using rule 16 (expr -> unary_operation .)
    GE              reduce using rule 16 (expr -> unary_operation .)
    GT              reduce using rule 16 (expr -> unary_operation .)
    AND             reduce using rule 16 (expr -> unary_operation .)
    OR              reduce using rule 16 (expr -> unary_operation .)
    AND2            reduce using rule 16 (expr -> unary_operation .)
    OR2             reduce using rule 16 (expr -> unary_operation .)
    MATRIX_MULT     reduce using rule 16 (expr -> unary_operation .)
    $               reduce using rule 16 (expr -> unary_operation .)
    @               reduce using rule 16 (expr -> unary_operation .)
    ;               reduce using rule 16 (expr -> unary_operation .)
    NLINE           reduce using rule 16 (expr -> unary_operation .)
    $end            reduce using rule 16 (expr -> unary_operation .)
    )               reduce using rule 16 (expr -> unary_operation .)
    }               reduce using rule 16 (expr -> unary_operation .)
    ]               reduce using rule 16 (expr -> unary_operation .)
    ,               reduce using rule 16 (expr -> unary_operation .)
    ELSE            reduce using rule 16 (expr -> unary_operation .)


state 10

    (17) expr -> statement_declaration .

    RIGHT_ASSIGN    reduce using rule 17 (expr -> statement_declaration .)
    [               reduce using rule 17 (expr -> statement_declaration .)
    LBB             reduce using rule 17 (expr -> statement_declaration .)
    +               reduce using rule 17 (expr -> statement_declaration .)
    -               reduce using rule 17 (expr -> statement_declaration .)
    *               reduce using rule 17 (expr -> statement_declaration .)
    POWER           reduce using rule 17 (expr -> statement_declaration .)
    MOD             reduce using rule 17 (expr -> statement_declaration .)
    INT_DIV         reduce using rule 17 (expr -> statement_declaration .)
    /               reduce using rule 17 (expr -> statement_declaration .)
    :               reduce using rule 17 (expr -> statement_declaration .)
    ~               reduce using rule 17 (expr -> statement_declaration .)
    ?               reduce using rule 17 (expr -> statement_declaration .)
    LT              reduce using rule 17 (expr -> statement_declaration .)
    LE              reduce using rule 17 (expr -> statement_declaration .)
    EQ              reduce using rule 17 (expr -> statement_declaration .)
    NE              reduce using rule 17 (expr -> statement_declaration .)
    GE              reduce using rule 17 (expr -> statement_declaration .)
    GT              reduce using rule 17 (expr -> statement_declaration .)
    AND             reduce using rule 17 (expr -> statement_declaration .)
    OR              reduce using rule 17 (expr -> statement_declaration .)
    AND2            reduce using rule 17 (expr -> statement_declaration .)
    OR2             reduce using rule 17 (expr -> statement_declaration .)
    MATRIX_MULT     reduce using rule 17 (expr -> statement_declaration .)
    $               reduce using rule 17 (expr -> statement_declaration .)
    @               reduce using rule 17 (expr -> statement_declaration .)
    ;               reduce using rule 17 (expr -> statement_declaration .)
    NLINE           reduce using rule 17 (expr -> statement_declaration .)
    $end            reduce using rule 17 (expr -> statement_declaration .)
    )               reduce using rule 17 (expr -> statement_declaration .)
    }               reduce using rule 17 (expr -> statement_declaration .)
    ]               reduce using rule 17 (expr -> statement_declaration .)
    ,               reduce using rule 17 (expr -> statement_declaration .)
    ELSE            reduce using rule 17 (expr -> statement_declaration .)


state 11

    (20) expr -> ( . expr_or_assign )
    (10) expr_or_assign -> . expr
    (11) expr_or_assign -> . SYMBOL EQ_ASSIGN expr_or_assign
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 6
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr_or_assign                 shift and go to state 63
    expr                           shift and go to state 5
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 12

    (23) expr -> { . exprlist }
    (4) exprlist -> . empty
    (5) exprlist -> . expr_or_assign
    (6) exprlist -> . exprlist ;
    (7) exprlist -> . exprlist emptyline
    (8) exprlist -> . exprlist ; expr_or_assign
    (9) exprlist -> . exprlist emptyline expr_or_assign
    (81) empty -> .
    (10) expr_or_assign -> . expr
    (11) expr_or_assign -> . SYMBOL EQ_ASSIGN expr_or_assign
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    }               reduce using rule 81 (empty -> .)
    ;               reduce using rule 81 (empty -> .)
    NLINE           reduce using rule 81 (empty -> .)
    SYMBOL          shift and go to state 6
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    exprlist                       shift and go to state 64
    empty                          shift and go to state 3
    expr_or_assign                 shift and go to state 4
    expr                           shift and go to state 5
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 13

    (24) expr -> FUNCTION . ( formlist ) expr_or_assign_nl

    (               shift and go to state 65


state 14

    (36) const_or_symbol -> STR_CONST .

    RIGHT_ASSIGN    reduce using rule 36 (const_or_symbol -> STR_CONST .)
    [               reduce using rule 36 (const_or_symbol -> STR_CONST .)
    LBB             reduce using rule 36 (const_or_symbol -> STR_CONST .)
    +               reduce using rule 36 (const_or_symbol -> STR_CONST .)
    -               reduce using rule 36 (const_or_symbol -> STR_CONST .)
    *               reduce using rule 36 (const_or_symbol -> STR_CONST .)
    POWER           reduce using rule 36 (const_or_symbol -> STR_CONST .)
    MOD             reduce using rule 36 (const_or_symbol -> STR_CONST .)
    INT_DIV         reduce using rule 36 (const_or_symbol -> STR_CONST .)
    /               reduce using rule 36 (const_or_symbol -> STR_CONST .)
    :               reduce using rule 36 (const_or_symbol -> STR_CONST .)
    ~               reduce using rule 36 (const_or_symbol -> STR_CONST .)
    ?               reduce using rule 36 (const_or_symbol -> STR_CONST .)
    LT              reduce using rule 36 (const_or_symbol -> STR_CONST .)
    LE              reduce using rule 36 (const_or_symbol -> STR_CONST .)
    EQ              reduce using rule 36 (const_or_symbol -> STR_CONST .)
    NE              reduce using rule 36 (const_or_symbol -> STR_CONST .)
    GE              reduce using rule 36 (const_or_symbol -> STR_CONST .)
    GT              reduce using rule 36 (const_or_symbol -> STR_CONST .)
    AND             reduce using rule 36 (const_or_symbol -> STR_CONST .)
    OR              reduce using rule 36 (const_or_symbol -> STR_CONST .)
    AND2            reduce using rule 36 (const_or_symbol -> STR_CONST .)
    OR2             reduce using rule 36 (const_or_symbol -> STR_CONST .)
    MATRIX_MULT     reduce using rule 36 (const_or_symbol -> STR_CONST .)
    $               reduce using rule 36 (const_or_symbol -> STR_CONST .)
    @               reduce using rule 36 (const_or_symbol -> STR_CONST .)
    ;               reduce using rule 36 (const_or_symbol -> STR_CONST .)
    NLINE           reduce using rule 36 (const_or_symbol -> STR_CONST .)
    $end            reduce using rule 36 (const_or_symbol -> STR_CONST .)
    )               reduce using rule 36 (const_or_symbol -> STR_CONST .)
    }               reduce using rule 36 (const_or_symbol -> STR_CONST .)
    ]               reduce using rule 36 (const_or_symbol -> STR_CONST .)
    ,               reduce using rule 36 (const_or_symbol -> STR_CONST .)
    ELSE            reduce using rule 36 (const_or_symbol -> STR_CONST .)


state 15

    (37) const_or_symbol -> REAL .

    RIGHT_ASSIGN    reduce using rule 37 (const_or_symbol -> REAL .)
    [               reduce using rule 37 (const_or_symbol -> REAL .)
    LBB             reduce using rule 37 (const_or_symbol -> REAL .)
    +               reduce using rule 37 (const_or_symbol -> REAL .)
    -               reduce using rule 37 (const_or_symbol -> REAL .)
    *               reduce using rule 37 (const_or_symbol -> REAL .)
    POWER           reduce using rule 37 (const_or_symbol -> REAL .)
    MOD             reduce using rule 37 (const_or_symbol -> REAL .)
    INT_DIV         reduce using rule 37 (const_or_symbol -> REAL .)
    /               reduce using rule 37 (const_or_symbol -> REAL .)
    :               reduce using rule 37 (const_or_symbol -> REAL .)
    ~               reduce using rule 37 (const_or_symbol -> REAL .)
    ?               reduce using rule 37 (const_or_symbol -> REAL .)
    LT              reduce using rule 37 (const_or_symbol -> REAL .)
    LE              reduce using rule 37 (const_or_symbol -> REAL .)
    EQ              reduce using rule 37 (const_or_symbol -> REAL .)
    NE              reduce using rule 37 (const_or_symbol -> REAL .)
    GE              reduce using rule 37 (const_or_symbol -> REAL .)
    GT              reduce using rule 37 (const_or_symbol -> REAL .)
    AND             reduce using rule 37 (const_or_symbol -> REAL .)
    OR              reduce using rule 37 (const_or_symbol -> REAL .)
    AND2            reduce using rule 37 (const_or_symbol -> REAL .)
    OR2             reduce using rule 37 (const_or_symbol -> REAL .)
    MATRIX_MULT     reduce using rule 37 (const_or_symbol -> REAL .)
    $               reduce using rule 37 (const_or_symbol -> REAL .)
    @               reduce using rule 37 (const_or_symbol -> REAL .)
    ;               reduce using rule 37 (const_or_symbol -> REAL .)
    NLINE           reduce using rule 37 (const_or_symbol -> REAL .)
    $end            reduce using rule 37 (const_or_symbol -> REAL .)
    )               reduce using rule 37 (const_or_symbol -> REAL .)
    }               reduce using rule 37 (const_or_symbol -> REAL .)
    ]               reduce using rule 37 (const_or_symbol -> REAL .)
    ,               reduce using rule 37 (const_or_symbol -> REAL .)
    ELSE            reduce using rule 37 (const_or_symbol -> REAL .)


state 16

    (38) const_or_symbol -> INT .

    RIGHT_ASSIGN    reduce using rule 38 (const_or_symbol -> INT .)
    [               reduce using rule 38 (const_or_symbol -> INT .)
    LBB             reduce using rule 38 (const_or_symbol -> INT .)
    +               reduce using rule 38 (const_or_symbol -> INT .)
    -               reduce using rule 38 (const_or_symbol -> INT .)
    *               reduce using rule 38 (const_or_symbol -> INT .)
    POWER           reduce using rule 38 (const_or_symbol -> INT .)
    MOD             reduce using rule 38 (const_or_symbol -> INT .)
    INT_DIV         reduce using rule 38 (const_or_symbol -> INT .)
    /               reduce using rule 38 (const_or_symbol -> INT .)
    :               reduce using rule 38 (const_or_symbol -> INT .)
    ~               reduce using rule 38 (const_or_symbol -> INT .)
    ?               reduce using rule 38 (const_or_symbol -> INT .)
    LT              reduce using rule 38 (const_or_symbol -> INT .)
    LE              reduce using rule 38 (const_or_symbol -> INT .)
    EQ              reduce using rule 38 (const_or_symbol -> INT .)
    NE              reduce using rule 38 (const_or_symbol -> INT .)
    GE              reduce using rule 38 (const_or_symbol -> INT .)
    GT              reduce using rule 38 (const_or_symbol -> INT .)
    AND             reduce using rule 38 (const_or_symbol -> INT .)
    OR              reduce using rule 38 (const_or_symbol -> INT .)
    AND2            reduce using rule 38 (const_or_symbol -> INT .)
    OR2             reduce using rule 38 (const_or_symbol -> INT .)
    MATRIX_MULT     reduce using rule 38 (const_or_symbol -> INT .)
    $               reduce using rule 38 (const_or_symbol -> INT .)
    @               reduce using rule 38 (const_or_symbol -> INT .)
    ;               reduce using rule 38 (const_or_symbol -> INT .)
    NLINE           reduce using rule 38 (const_or_symbol -> INT .)
    $end            reduce using rule 38 (const_or_symbol -> INT .)
    )               reduce using rule 38 (const_or_symbol -> INT .)
    }               reduce using rule 38 (const_or_symbol -> INT .)
    ]               reduce using rule 38 (const_or_symbol -> INT .)
    ,               reduce using rule 38 (const_or_symbol -> INT .)
    ELSE            reduce using rule 38 (const_or_symbol -> INT .)


state 17

    (39) const_or_symbol -> NULL_CONST .

    RIGHT_ASSIGN    reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    [               reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    LBB             reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    +               reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    -               reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    *               reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    POWER           reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    MOD             reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    INT_DIV         reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    /               reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    :               reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    ~               reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    ?               reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    LT              reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    LE              reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    EQ              reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    NE              reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    GE              reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    GT              reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    AND             reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    OR              reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    AND2            reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    OR2             reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    MATRIX_MULT     reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    $               reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    @               reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    ;               reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    NLINE           reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    $end            reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    )               reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    }               reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    ]               reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    ,               reduce using rule 39 (const_or_symbol -> NULL_CONST .)
    ELSE            reduce using rule 39 (const_or_symbol -> NULL_CONST .)


state 18

    (40) const_or_symbol -> TRUE .

    RIGHT_ASSIGN    reduce using rule 40 (const_or_symbol -> TRUE .)
    [               reduce using rule 40 (const_or_symbol -> TRUE .)
    LBB             reduce using rule 40 (const_or_symbol -> TRUE .)
    +               reduce using rule 40 (const_or_symbol -> TRUE .)
    -               reduce using rule 40 (const_or_symbol -> TRUE .)
    *               reduce using rule 40 (const_or_symbol -> TRUE .)
    POWER           reduce using rule 40 (const_or_symbol -> TRUE .)
    MOD             reduce using rule 40 (const_or_symbol -> TRUE .)
    INT_DIV         reduce using rule 40 (const_or_symbol -> TRUE .)
    /               reduce using rule 40 (const_or_symbol -> TRUE .)
    :               reduce using rule 40 (const_or_symbol -> TRUE .)
    ~               reduce using rule 40 (const_or_symbol -> TRUE .)
    ?               reduce using rule 40 (const_or_symbol -> TRUE .)
    LT              reduce using rule 40 (const_or_symbol -> TRUE .)
    LE              reduce using rule 40 (const_or_symbol -> TRUE .)
    EQ              reduce using rule 40 (const_or_symbol -> TRUE .)
    NE              reduce using rule 40 (const_or_symbol -> TRUE .)
    GE              reduce using rule 40 (const_or_symbol -> TRUE .)
    GT              reduce using rule 40 (const_or_symbol -> TRUE .)
    AND             reduce using rule 40 (const_or_symbol -> TRUE .)
    OR              reduce using rule 40 (const_or_symbol -> TRUE .)
    AND2            reduce using rule 40 (const_or_symbol -> TRUE .)
    OR2             reduce using rule 40 (const_or_symbol -> TRUE .)
    MATRIX_MULT     reduce using rule 40 (const_or_symbol -> TRUE .)
    $               reduce using rule 40 (const_or_symbol -> TRUE .)
    @               reduce using rule 40 (const_or_symbol -> TRUE .)
    ;               reduce using rule 40 (const_or_symbol -> TRUE .)
    NLINE           reduce using rule 40 (const_or_symbol -> TRUE .)
    $end            reduce using rule 40 (const_or_symbol -> TRUE .)
    )               reduce using rule 40 (const_or_symbol -> TRUE .)
    }               reduce using rule 40 (const_or_symbol -> TRUE .)
    ]               reduce using rule 40 (const_or_symbol -> TRUE .)
    ,               reduce using rule 40 (const_or_symbol -> TRUE .)
    ELSE            reduce using rule 40 (const_or_symbol -> TRUE .)


state 19

    (41) const_or_symbol -> FALSE .

    RIGHT_ASSIGN    reduce using rule 41 (const_or_symbol -> FALSE .)
    [               reduce using rule 41 (const_or_symbol -> FALSE .)
    LBB             reduce using rule 41 (const_or_symbol -> FALSE .)
    +               reduce using rule 41 (const_or_symbol -> FALSE .)
    -               reduce using rule 41 (const_or_symbol -> FALSE .)
    *               reduce using rule 41 (const_or_symbol -> FALSE .)
    POWER           reduce using rule 41 (const_or_symbol -> FALSE .)
    MOD             reduce using rule 41 (const_or_symbol -> FALSE .)
    INT_DIV         reduce using rule 41 (const_or_symbol -> FALSE .)
    /               reduce using rule 41 (const_or_symbol -> FALSE .)
    :               reduce using rule 41 (const_or_symbol -> FALSE .)
    ~               reduce using rule 41 (const_or_symbol -> FALSE .)
    ?               reduce using rule 41 (const_or_symbol -> FALSE .)
    LT              reduce using rule 41 (const_or_symbol -> FALSE .)
    LE              reduce using rule 41 (const_or_symbol -> FALSE .)
    EQ              reduce using rule 41 (const_or_symbol -> FALSE .)
    NE              reduce using rule 41 (const_or_symbol -> FALSE .)
    GE              reduce using rule 41 (const_or_symbol -> FALSE .)
    GT              reduce using rule 41 (const_or_symbol -> FALSE .)
    AND             reduce using rule 41 (const_or_symbol -> FALSE .)
    OR              reduce using rule 41 (const_or_symbol -> FALSE .)
    AND2            reduce using rule 41 (const_or_symbol -> FALSE .)
    OR2             reduce using rule 41 (const_or_symbol -> FALSE .)
    MATRIX_MULT     reduce using rule 41 (const_or_symbol -> FALSE .)
    $               reduce using rule 41 (const_or_symbol -> FALSE .)
    @               reduce using rule 41 (const_or_symbol -> FALSE .)
    ;               reduce using rule 41 (const_or_symbol -> FALSE .)
    NLINE           reduce using rule 41 (const_or_symbol -> FALSE .)
    $end            reduce using rule 41 (const_or_symbol -> FALSE .)
    )               reduce using rule 41 (const_or_symbol -> FALSE .)
    }               reduce using rule 41 (const_or_symbol -> FALSE .)
    ]               reduce using rule 41 (const_or_symbol -> FALSE .)
    ,               reduce using rule 41 (const_or_symbol -> FALSE .)
    ELSE            reduce using rule 41 (const_or_symbol -> FALSE .)


state 20

    (68) unary_operation -> + . expr
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 66
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 21

    (67) unary_operation -> - . expr
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 68
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 22

    (70) unary_operation -> ~ . expr
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 69
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 23

    (71) unary_operation -> ? . expr
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 70
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 24

    (69) unary_operation -> ! . expr
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 71
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 25

    (72) statement_declaration -> if_statement .

    RIGHT_ASSIGN    reduce using rule 72 (statement_declaration -> if_statement .)
    [               reduce using rule 72 (statement_declaration -> if_statement .)
    LBB             reduce using rule 72 (statement_declaration -> if_statement .)
    +               reduce using rule 72 (statement_declaration -> if_statement .)
    -               reduce using rule 72 (statement_declaration -> if_statement .)
    *               reduce using rule 72 (statement_declaration -> if_statement .)
    POWER           reduce using rule 72 (statement_declaration -> if_statement .)
    MOD             reduce using rule 72 (statement_declaration -> if_statement .)
    INT_DIV         reduce using rule 72 (statement_declaration -> if_statement .)
    /               reduce using rule 72 (statement_declaration -> if_statement .)
    :               reduce using rule 72 (statement_declaration -> if_statement .)
    ~               reduce using rule 72 (statement_declaration -> if_statement .)
    ?               reduce using rule 72 (statement_declaration -> if_statement .)
    LT              reduce using rule 72 (statement_declaration -> if_statement .)
    LE              reduce using rule 72 (statement_declaration -> if_statement .)
    EQ              reduce using rule 72 (statement_declaration -> if_statement .)
    NE              reduce using rule 72 (statement_declaration -> if_statement .)
    GE              reduce using rule 72 (statement_declaration -> if_statement .)
    GT              reduce using rule 72 (statement_declaration -> if_statement .)
    AND             reduce using rule 72 (statement_declaration -> if_statement .)
    OR              reduce using rule 72 (statement_declaration -> if_statement .)
    AND2            reduce using rule 72 (statement_declaration -> if_statement .)
    OR2             reduce using rule 72 (statement_declaration -> if_statement .)
    MATRIX_MULT     reduce using rule 72 (statement_declaration -> if_statement .)
    $               reduce using rule 72 (statement_declaration -> if_statement .)
    @               reduce using rule 72 (statement_declaration -> if_statement .)
    ;               reduce using rule 72 (statement_declaration -> if_statement .)
    NLINE           reduce using rule 72 (statement_declaration -> if_statement .)
    $end            reduce using rule 72 (statement_declaration -> if_statement .)
    )               reduce using rule 72 (statement_declaration -> if_statement .)
    }               reduce using rule 72 (statement_declaration -> if_statement .)
    ]               reduce using rule 72 (statement_declaration -> if_statement .)
    ,               reduce using rule 72 (statement_declaration -> if_statement .)
    ELSE            reduce using rule 72 (statement_declaration -> if_statement .)


state 26

    (73) statement_declaration -> for_statement .

    RIGHT_ASSIGN    reduce using rule 73 (statement_declaration -> for_statement .)
    [               reduce using rule 73 (statement_declaration -> for_statement .)
    LBB             reduce using rule 73 (statement_declaration -> for_statement .)
    +               reduce using rule 73 (statement_declaration -> for_statement .)
    -               reduce using rule 73 (statement_declaration -> for_statement .)
    *               reduce using rule 73 (statement_declaration -> for_statement .)
    POWER           reduce using rule 73 (statement_declaration -> for_statement .)
    MOD             reduce using rule 73 (statement_declaration -> for_statement .)
    INT_DIV         reduce using rule 73 (statement_declaration -> for_statement .)
    /               reduce using rule 73 (statement_declaration -> for_statement .)
    :               reduce using rule 73 (statement_declaration -> for_statement .)
    ~               reduce using rule 73 (statement_declaration -> for_statement .)
    ?               reduce using rule 73 (statement_declaration -> for_statement .)
    LT              reduce using rule 73 (statement_declaration -> for_statement .)
    LE              reduce using rule 73 (statement_declaration -> for_statement .)
    EQ              reduce using rule 73 (statement_declaration -> for_statement .)
    NE              reduce using rule 73 (statement_declaration -> for_statement .)
    GE              reduce using rule 73 (statement_declaration -> for_statement .)
    GT              reduce using rule 73 (statement_declaration -> for_statement .)
    AND             reduce using rule 73 (statement_declaration -> for_statement .)
    OR              reduce using rule 73 (statement_declaration -> for_statement .)
    AND2            reduce using rule 73 (statement_declaration -> for_statement .)
    OR2             reduce using rule 73 (statement_declaration -> for_statement .)
    MATRIX_MULT     reduce using rule 73 (statement_declaration -> for_statement .)
    $               reduce using rule 73 (statement_declaration -> for_statement .)
    @               reduce using rule 73 (statement_declaration -> for_statement .)
    ;               reduce using rule 73 (statement_declaration -> for_statement .)
    NLINE           reduce using rule 73 (statement_declaration -> for_statement .)
    $end            reduce using rule 73 (statement_declaration -> for_statement .)
    )               reduce using rule 73 (statement_declaration -> for_statement .)
    }               reduce using rule 73 (statement_declaration -> for_statement .)
    ]               reduce using rule 73 (statement_declaration -> for_statement .)
    ,               reduce using rule 73 (statement_declaration -> for_statement .)
    ELSE            reduce using rule 73 (statement_declaration -> for_statement .)


state 27

    (74) statement_declaration -> while_statement .

    RIGHT_ASSIGN    reduce using rule 74 (statement_declaration -> while_statement .)
    [               reduce using rule 74 (statement_declaration -> while_statement .)
    LBB             reduce using rule 74 (statement_declaration -> while_statement .)
    +               reduce using rule 74 (statement_declaration -> while_statement .)
    -               reduce using rule 74 (statement_declaration -> while_statement .)
    *               reduce using rule 74 (statement_declaration -> while_statement .)
    POWER           reduce using rule 74 (statement_declaration -> while_statement .)
    MOD             reduce using rule 74 (statement_declaration -> while_statement .)
    INT_DIV         reduce using rule 74 (statement_declaration -> while_statement .)
    /               reduce using rule 74 (statement_declaration -> while_statement .)
    :               reduce using rule 74 (statement_declaration -> while_statement .)
    ~               reduce using rule 74 (statement_declaration -> while_statement .)
    ?               reduce using rule 74 (statement_declaration -> while_statement .)
    LT              reduce using rule 74 (statement_declaration -> while_statement .)
    LE              reduce using rule 74 (statement_declaration -> while_statement .)
    EQ              reduce using rule 74 (statement_declaration -> while_statement .)
    NE              reduce using rule 74 (statement_declaration -> while_statement .)
    GE              reduce using rule 74 (statement_declaration -> while_statement .)
    GT              reduce using rule 74 (statement_declaration -> while_statement .)
    AND             reduce using rule 74 (statement_declaration -> while_statement .)
    OR              reduce using rule 74 (statement_declaration -> while_statement .)
    AND2            reduce using rule 74 (statement_declaration -> while_statement .)
    OR2             reduce using rule 74 (statement_declaration -> while_statement .)
    MATRIX_MULT     reduce using rule 74 (statement_declaration -> while_statement .)
    $               reduce using rule 74 (statement_declaration -> while_statement .)
    @               reduce using rule 74 (statement_declaration -> while_statement .)
    ;               reduce using rule 74 (statement_declaration -> while_statement .)
    NLINE           reduce using rule 74 (statement_declaration -> while_statement .)
    $end            reduce using rule 74 (statement_declaration -> while_statement .)
    )               reduce using rule 74 (statement_declaration -> while_statement .)
    }               reduce using rule 74 (statement_declaration -> while_statement .)
    ]               reduce using rule 74 (statement_declaration -> while_statement .)
    ,               reduce using rule 74 (statement_declaration -> while_statement .)
    ELSE            reduce using rule 74 (statement_declaration -> while_statement .)


state 28

    (75) if_statement -> IF . ( expr ) expr_or_assign_nl else_statement

    (               shift and go to state 72


state 29

    (79) for_statement -> FOR . ( SYMBOL IN expr ) expr_or_assign_nl

    (               shift and go to state 73


state 30

    (80) while_statement -> WHILE . ( expr ) expr_or_assign_nl

    (               shift and go to state 74


state 31

    (6) exprlist -> exprlist ; .
    (8) exprlist -> exprlist ; . expr_or_assign
    (10) expr_or_assign -> . expr
    (11) expr_or_assign -> . SYMBOL EQ_ASSIGN expr_or_assign
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    ;               reduce using rule 6 (exprlist -> exprlist ; .)
    NLINE           reduce using rule 6 (exprlist -> exprlist ; .)
    $end            reduce using rule 6 (exprlist -> exprlist ; .)
    }               reduce using rule 6 (exprlist -> exprlist ; .)
    SYMBOL          shift and go to state 6
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr_or_assign                 shift and go to state 75
    expr                           shift and go to state 5
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 32

    (7) exprlist -> exprlist emptyline .
    (9) exprlist -> exprlist emptyline . expr_or_assign
    (3) emptyline -> emptyline . NLINE
    (10) expr_or_assign -> . expr
    (11) expr_or_assign -> . SYMBOL EQ_ASSIGN expr_or_assign
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

  ! shift/reduce conflict for NLINE resolved as shift
    ;               reduce using rule 7 (exprlist -> exprlist emptyline .)
    $end            reduce using rule 7 (exprlist -> exprlist emptyline .)
    }               reduce using rule 7 (exprlist -> exprlist emptyline .)
    NLINE           shift and go to state 77
    SYMBOL          shift and go to state 6
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

  ! NLINE           [ reduce using rule 7 (exprlist -> exprlist emptyline .) ]

    expr_or_assign                 shift and go to state 76
    expr                           shift and go to state 5
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 33

    (2) emptyline -> NLINE .

    NLINE           reduce using rule 2 (emptyline -> NLINE .)
    SYMBOL          reduce using rule 2 (emptyline -> NLINE .)
    (               reduce using rule 2 (emptyline -> NLINE .)
    {               reduce using rule 2 (emptyline -> NLINE .)
    FUNCTION        reduce using rule 2 (emptyline -> NLINE .)
    STR_CONST       reduce using rule 2 (emptyline -> NLINE .)
    REAL            reduce using rule 2 (emptyline -> NLINE .)
    INT             reduce using rule 2 (emptyline -> NLINE .)
    NULL_CONST      reduce using rule 2 (emptyline -> NLINE .)
    TRUE            reduce using rule 2 (emptyline -> NLINE .)
    FALSE           reduce using rule 2 (emptyline -> NLINE .)
    -               reduce using rule 2 (emptyline -> NLINE .)
    +               reduce using rule 2 (emptyline -> NLINE .)
    !               reduce using rule 2 (emptyline -> NLINE .)
    ~               reduce using rule 2 (emptyline -> NLINE .)
    ?               reduce using rule 2 (emptyline -> NLINE .)
    IF              reduce using rule 2 (emptyline -> NLINE .)
    FOR             reduce using rule 2 (emptyline -> NLINE .)
    WHILE           reduce using rule 2 (emptyline -> NLINE .)
    ;               reduce using rule 2 (emptyline -> NLINE .)
    $end            reduce using rule 2 (emptyline -> NLINE .)
    }               reduce using rule 2 (emptyline -> NLINE .)


state 34

    (18) expr -> expr RIGHT_ASSIGN . SYMBOL

    SYMBOL          shift and go to state 78


state 35

    (21) expr -> expr [ . sublist ]
    (31) sublist -> . sub
    (32) sublist -> . sublist , sub
    (33) sub -> . empty
    (34) sub -> . expr
    (81) empty -> .
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    ]               reduce using rule 81 (empty -> .)
    ,               reduce using rule 81 (empty -> .)
    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 79
    sublist                        shift and go to state 80
    sub                            shift and go to state 81
    empty                          shift and go to state 82
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 36

    (22) expr -> expr LBB . sublist ] ]
    (31) sublist -> . sub
    (32) sublist -> . sublist , sub
    (33) sub -> . empty
    (34) sub -> . expr
    (81) empty -> .
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    ]               reduce using rule 81 (empty -> .)
    ,               reduce using rule 81 (empty -> .)
    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 79
    sublist                        shift and go to state 83
    sub                            shift and go to state 81
    empty                          shift and go to state 82
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 37

    (42) binary_operation -> expr + . expr
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 84
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 38

    (43) binary_operation -> expr - . expr
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 85
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 39

    (44) binary_operation -> expr * . expr
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 86
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 40

    (45) binary_operation -> expr POWER . expr
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 87
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 41

    (46) binary_operation -> expr MOD . expr
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 88
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 42

    (47) binary_operation -> expr INT_DIV . expr
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 89
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 43

    (48) binary_operation -> expr / . expr
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 90
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 44

    (49) binary_operation -> expr : . expr
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 91
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 45

    (50) binary_operation -> expr ~ . expr
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 92
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 46

    (51) binary_operation -> expr ? . expr
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 93
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 47

    (52) binary_operation -> expr LT . expr
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 94
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 48

    (53) binary_operation -> expr LE . expr
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 95
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 49

    (54) binary_operation -> expr EQ . expr
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 96
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 50

    (55) binary_operation -> expr NE . expr
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 97
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 51

    (56) binary_operation -> expr GE . expr
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 98
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 52

    (57) binary_operation -> expr GT . expr
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 99
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 53

    (58) binary_operation -> expr AND . expr
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 100
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 54

    (59) binary_operation -> expr OR . expr
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 101
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 55

    (60) binary_operation -> expr AND2 . expr
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 102
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 56

    (61) binary_operation -> expr OR2 . expr
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 103
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 57

    (62) binary_operation -> expr MATRIX_MULT . expr
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 104
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 58

    (63) binary_operation -> expr $ . SYMBOL
    (64) binary_operation -> expr $ . STR_CONST

    SYMBOL          shift and go to state 105
    STR_CONST       shift and go to state 106


state 59

    (65) binary_operation -> expr @ . SYMBOL
    (66) binary_operation -> expr @ . STR_CONST

    SYMBOL          shift and go to state 107
    STR_CONST       shift and go to state 108


state 60

    (11) expr_or_assign -> SYMBOL EQ_ASSIGN . expr_or_assign
    (10) expr_or_assign -> . expr
    (11) expr_or_assign -> . SYMBOL EQ_ASSIGN expr_or_assign
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 6
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr_or_assign                 shift and go to state 109
    expr                           shift and go to state 5
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 61

    (19) expr -> SYMBOL LEFT_ASSIGN . expr
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 110
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 62

    (25) expr -> SYMBOL ( . sublist )
    (31) sublist -> . sub
    (32) sublist -> . sublist , sub
    (33) sub -> . empty
    (34) sub -> . expr
    (81) empty -> .
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    )               reduce using rule 81 (empty -> .)
    ,               reduce using rule 81 (empty -> .)
    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    sublist                        shift and go to state 111
    sub                            shift and go to state 81
    empty                          shift and go to state 82
    expr                           shift and go to state 79
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 63

    (20) expr -> ( expr_or_assign . )

    )               shift and go to state 112


state 64

    (23) expr -> { exprlist . }
    (6) exprlist -> exprlist . ;
    (7) exprlist -> exprlist . emptyline
    (8) exprlist -> exprlist . ; expr_or_assign
    (9) exprlist -> exprlist . emptyline expr_or_assign
    (2) emptyline -> . NLINE
    (3) emptyline -> . emptyline NLINE

    }               shift and go to state 113
    ;               shift and go to state 31
    NLINE           shift and go to state 33

    emptyline                      shift and go to state 32

state 65

    (24) expr -> FUNCTION ( . formlist ) expr_or_assign_nl
    (26) formlist -> . SYMBOL
    (27) formlist -> . SYMBOL EQ_ASSIGN expr
    (28) formlist -> . formlist , SYMBOL
    (29) formlist -> . formlist , SYMBOL EQ_ASSIGN expr
    (30) formlist -> . empty
    (81) empty -> .

    SYMBOL          shift and go to state 115
    )               reduce using rule 81 (empty -> .)
    ,               reduce using rule 81 (empty -> .)

    formlist                       shift and go to state 114
    empty                          shift and go to state 116

state 66

    (68) unary_operation -> + expr .
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    RIGHT_ASSIGN    reduce using rule 68 (unary_operation -> + expr .)
    +               reduce using rule 68 (unary_operation -> + expr .)
    -               reduce using rule 68 (unary_operation -> + expr .)
    *               reduce using rule 68 (unary_operation -> + expr .)
    MOD             reduce using rule 68 (unary_operation -> + expr .)
    INT_DIV         reduce using rule 68 (unary_operation -> + expr .)
    /               reduce using rule 68 (unary_operation -> + expr .)
    :               reduce using rule 68 (unary_operation -> + expr .)
    ~               reduce using rule 68 (unary_operation -> + expr .)
    ?               reduce using rule 68 (unary_operation -> + expr .)
    LT              reduce using rule 68 (unary_operation -> + expr .)
    LE              reduce using rule 68 (unary_operation -> + expr .)
    EQ              reduce using rule 68 (unary_operation -> + expr .)
    NE              reduce using rule 68 (unary_operation -> + expr .)
    GE              reduce using rule 68 (unary_operation -> + expr .)
    GT              reduce using rule 68 (unary_operation -> + expr .)
    AND             reduce using rule 68 (unary_operation -> + expr .)
    OR              reduce using rule 68 (unary_operation -> + expr .)
    AND2            reduce using rule 68 (unary_operation -> + expr .)
    OR2             reduce using rule 68 (unary_operation -> + expr .)
    MATRIX_MULT     reduce using rule 68 (unary_operation -> + expr .)
    ;               reduce using rule 68 (unary_operation -> + expr .)
    NLINE           reduce using rule 68 (unary_operation -> + expr .)
    $end            reduce using rule 68 (unary_operation -> + expr .)
    )               reduce using rule 68 (unary_operation -> + expr .)
    }               reduce using rule 68 (unary_operation -> + expr .)
    ]               reduce using rule 68 (unary_operation -> + expr .)
    ,               reduce using rule 68 (unary_operation -> + expr .)
    ELSE            reduce using rule 68 (unary_operation -> + expr .)
    [               shift and go to state 35
    LBB             shift and go to state 36
    POWER           shift and go to state 40
    $               shift and go to state 58
    @               shift and go to state 59

  ! [               [ reduce using rule 68 (unary_operation -> + expr .) ]
  ! LBB             [ reduce using rule 68 (unary_operation -> + expr .) ]
  ! POWER           [ reduce using rule 68 (unary_operation -> + expr .) ]
  ! $               [ reduce using rule 68 (unary_operation -> + expr .) ]
  ! @               [ reduce using rule 68 (unary_operation -> + expr .) ]
  ! RIGHT_ASSIGN    [ shift and go to state 34 ]
  ! +               [ shift and go to state 37 ]
  ! -               [ shift and go to state 38 ]
  ! *               [ shift and go to state 39 ]
  ! MOD             [ shift and go to state 41 ]
  ! INT_DIV         [ shift and go to state 42 ]
  ! /               [ shift and go to state 43 ]
  ! :               [ shift and go to state 44 ]
  ! ~               [ shift and go to state 45 ]
  ! ?               [ shift and go to state 46 ]
  ! LT              [ shift and go to state 47 ]
  ! LE              [ shift and go to state 48 ]
  ! EQ              [ shift and go to state 49 ]
  ! NE              [ shift and go to state 50 ]
  ! GE              [ shift and go to state 51 ]
  ! GT              [ shift and go to state 52 ]
  ! AND             [ shift and go to state 53 ]
  ! OR              [ shift and go to state 54 ]
  ! AND2            [ shift and go to state 55 ]
  ! OR2             [ shift and go to state 56 ]
  ! MATRIX_MULT     [ shift and go to state 57 ]


state 67

    (19) expr -> SYMBOL . LEFT_ASSIGN expr
    (25) expr -> SYMBOL . ( sublist )
    (35) const_or_symbol -> SYMBOL .

    LEFT_ASSIGN     shift and go to state 61
    (               shift and go to state 62
    RIGHT_ASSIGN    reduce using rule 35 (const_or_symbol -> SYMBOL .)
    [               reduce using rule 35 (const_or_symbol -> SYMBOL .)
    LBB             reduce using rule 35 (const_or_symbol -> SYMBOL .)
    +               reduce using rule 35 (const_or_symbol -> SYMBOL .)
    -               reduce using rule 35 (const_or_symbol -> SYMBOL .)
    *               reduce using rule 35 (const_or_symbol -> SYMBOL .)
    POWER           reduce using rule 35 (const_or_symbol -> SYMBOL .)
    MOD             reduce using rule 35 (const_or_symbol -> SYMBOL .)
    INT_DIV         reduce using rule 35 (const_or_symbol -> SYMBOL .)
    /               reduce using rule 35 (const_or_symbol -> SYMBOL .)
    :               reduce using rule 35 (const_or_symbol -> SYMBOL .)
    ~               reduce using rule 35 (const_or_symbol -> SYMBOL .)
    ?               reduce using rule 35 (const_or_symbol -> SYMBOL .)
    LT              reduce using rule 35 (const_or_symbol -> SYMBOL .)
    LE              reduce using rule 35 (const_or_symbol -> SYMBOL .)
    EQ              reduce using rule 35 (const_or_symbol -> SYMBOL .)
    NE              reduce using rule 35 (const_or_symbol -> SYMBOL .)
    GE              reduce using rule 35 (const_or_symbol -> SYMBOL .)
    GT              reduce using rule 35 (const_or_symbol -> SYMBOL .)
    AND             reduce using rule 35 (const_or_symbol -> SYMBOL .)
    OR              reduce using rule 35 (const_or_symbol -> SYMBOL .)
    AND2            reduce using rule 35 (const_or_symbol -> SYMBOL .)
    OR2             reduce using rule 35 (const_or_symbol -> SYMBOL .)
    MATRIX_MULT     reduce using rule 35 (const_or_symbol -> SYMBOL .)
    $               reduce using rule 35 (const_or_symbol -> SYMBOL .)
    @               reduce using rule 35 (const_or_symbol -> SYMBOL .)
    ;               reduce using rule 35 (const_or_symbol -> SYMBOL .)
    NLINE           reduce using rule 35 (const_or_symbol -> SYMBOL .)
    $end            reduce using rule 35 (const_or_symbol -> SYMBOL .)
    )               reduce using rule 35 (const_or_symbol -> SYMBOL .)
    }               reduce using rule 35 (const_or_symbol -> SYMBOL .)
    ]               reduce using rule 35 (const_or_symbol -> SYMBOL .)
    ,               reduce using rule 35 (const_or_symbol -> SYMBOL .)
    ELSE            reduce using rule 35 (const_or_symbol -> SYMBOL .)


state 68

    (67) unary_operation -> - expr .
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    RIGHT_ASSIGN    reduce using rule 67 (unary_operation -> - expr .)
    +               reduce using rule 67 (unary_operation -> - expr .)
    -               reduce using rule 67 (unary_operation -> - expr .)
    *               reduce using rule 67 (unary_operation -> - expr .)
    MOD             reduce using rule 67 (unary_operation -> - expr .)
    INT_DIV         reduce using rule 67 (unary_operation -> - expr .)
    /               reduce using rule 67 (unary_operation -> - expr .)
    :               reduce using rule 67 (unary_operation -> - expr .)
    ~               reduce using rule 67 (unary_operation -> - expr .)
    ?               reduce using rule 67 (unary_operation -> - expr .)
    LT              reduce using rule 67 (unary_operation -> - expr .)
    LE              reduce using rule 67 (unary_operation -> - expr .)
    EQ              reduce using rule 67 (unary_operation -> - expr .)
    NE              reduce using rule 67 (unary_operation -> - expr .)
    GE              reduce using rule 67 (unary_operation -> - expr .)
    GT              reduce using rule 67 (unary_operation -> - expr .)
    AND             reduce using rule 67 (unary_operation -> - expr .)
    OR              reduce using rule 67 (unary_operation -> - expr .)
    AND2            reduce using rule 67 (unary_operation -> - expr .)
    OR2             reduce using rule 67 (unary_operation -> - expr .)
    MATRIX_MULT     reduce using rule 67 (unary_operation -> - expr .)
    ;               reduce using rule 67 (unary_operation -> - expr .)
    NLINE           reduce using rule 67 (unary_operation -> - expr .)
    $end            reduce using rule 67 (unary_operation -> - expr .)
    )               reduce using rule 67 (unary_operation -> - expr .)
    }               reduce using rule 67 (unary_operation -> - expr .)
    ]               reduce using rule 67 (unary_operation -> - expr .)
    ,               reduce using rule 67 (unary_operation -> - expr .)
    ELSE            reduce using rule 67 (unary_operation -> - expr .)
    [               shift and go to state 35
    LBB             shift and go to state 36
    POWER           shift and go to state 40
    $               shift and go to state 58
    @               shift and go to state 59

  ! [               [ reduce using rule 67 (unary_operation -> - expr .) ]
  ! LBB             [ reduce using rule 67 (unary_operation -> - expr .) ]
  ! POWER           [ reduce using rule 67 (unary_operation -> - expr .) ]
  ! $               [ reduce using rule 67 (unary_operation -> - expr .) ]
  ! @               [ reduce using rule 67 (unary_operation -> - expr .) ]
  ! RIGHT_ASSIGN    [ shift and go to state 34 ]
  ! +               [ shift and go to state 37 ]
  ! -               [ shift and go to state 38 ]
  ! *               [ shift and go to state 39 ]
  ! MOD             [ shift and go to state 41 ]
  ! INT_DIV         [ shift and go to state 42 ]
  ! /               [ shift and go to state 43 ]
  ! :               [ shift and go to state 44 ]
  ! ~               [ shift and go to state 45 ]
  ! ?               [ shift and go to state 46 ]
  ! LT              [ shift and go to state 47 ]
  ! LE              [ shift and go to state 48 ]
  ! EQ              [ shift and go to state 49 ]
  ! NE              [ shift and go to state 50 ]
  ! GE              [ shift and go to state 51 ]
  ! GT              [ shift and go to state 52 ]
  ! AND             [ shift and go to state 53 ]
  ! OR              [ shift and go to state 54 ]
  ! AND2            [ shift and go to state 55 ]
  ! OR2             [ shift and go to state 56 ]
  ! MATRIX_MULT     [ shift and go to state 57 ]


state 69

    (70) unary_operation -> ~ expr .
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    RIGHT_ASSIGN    reduce using rule 70 (unary_operation -> ~ expr .)
    ~               reduce using rule 70 (unary_operation -> ~ expr .)
    ?               reduce using rule 70 (unary_operation -> ~ expr .)
    ;               reduce using rule 70 (unary_operation -> ~ expr .)
    NLINE           reduce using rule 70 (unary_operation -> ~ expr .)
    $end            reduce using rule 70 (unary_operation -> ~ expr .)
    )               reduce using rule 70 (unary_operation -> ~ expr .)
    }               reduce using rule 70 (unary_operation -> ~ expr .)
    ]               reduce using rule 70 (unary_operation -> ~ expr .)
    ,               reduce using rule 70 (unary_operation -> ~ expr .)
    ELSE            reduce using rule 70 (unary_operation -> ~ expr .)
    [               shift and go to state 35
    LBB             shift and go to state 36
    +               shift and go to state 37
    -               shift and go to state 38
    *               shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 41
    INT_DIV         shift and go to state 42
    /               shift and go to state 43
    :               shift and go to state 44
    LT              shift and go to state 47
    LE              shift and go to state 48
    EQ              shift and go to state 49
    NE              shift and go to state 50
    GE              shift and go to state 51
    GT              shift and go to state 52
    AND             shift and go to state 53
    OR              shift and go to state 54
    AND2            shift and go to state 55
    OR2             shift and go to state 56
    MATRIX_MULT     shift and go to state 57
    $               shift and go to state 58
    @               shift and go to state 59

  ! [               [ reduce using rule 70 (unary_operation -> ~ expr .) ]
  ! LBB             [ reduce using rule 70 (unary_operation -> ~ expr .) ]
  ! +               [ reduce using rule 70 (unary_operation -> ~ expr .) ]
  ! -               [ reduce using rule 70 (unary_operation -> ~ expr .) ]
  ! *               [ reduce using rule 70 (unary_operation -> ~ expr .) ]
  ! POWER           [ reduce using rule 70 (unary_operation -> ~ expr .) ]
  ! MOD             [ reduce using rule 70 (unary_operation -> ~ expr .) ]
  ! INT_DIV         [ reduce using rule 70 (unary_operation -> ~ expr .) ]
  ! /               [ reduce using rule 70 (unary_operation -> ~ expr .) ]
  ! :               [ reduce using rule 70 (unary_operation -> ~ expr .) ]
  ! LT              [ reduce using rule 70 (unary_operation -> ~ expr .) ]
  ! LE              [ reduce using rule 70 (unary_operation -> ~ expr .) ]
  ! EQ              [ reduce using rule 70 (unary_operation -> ~ expr .) ]
  ! NE              [ reduce using rule 70 (unary_operation -> ~ expr .) ]
  ! GE              [ reduce using rule 70 (unary_operation -> ~ expr .) ]
  ! GT              [ reduce using rule 70 (unary_operation -> ~ expr .) ]
  ! AND             [ reduce using rule 70 (unary_operation -> ~ expr .) ]
  ! OR              [ reduce using rule 70 (unary_operation -> ~ expr .) ]
  ! AND2            [ reduce using rule 70 (unary_operation -> ~ expr .) ]
  ! OR2             [ reduce using rule 70 (unary_operation -> ~ expr .) ]
  ! MATRIX_MULT     [ reduce using rule 70 (unary_operation -> ~ expr .) ]
  ! $               [ reduce using rule 70 (unary_operation -> ~ expr .) ]
  ! @               [ reduce using rule 70 (unary_operation -> ~ expr .) ]
  ! RIGHT_ASSIGN    [ shift and go to state 34 ]
  ! ~               [ shift and go to state 45 ]
  ! ?               [ shift and go to state 46 ]


state 70

    (71) unary_operation -> ? expr .
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    ?               reduce using rule 71 (unary_operation -> ? expr .)
    ;               reduce using rule 71 (unary_operation -> ? expr .)
    NLINE           reduce using rule 71 (unary_operation -> ? expr .)
    $end            reduce using rule 71 (unary_operation -> ? expr .)
    )               reduce using rule 71 (unary_operation -> ? expr .)
    }               reduce using rule 71 (unary_operation -> ? expr .)
    ]               reduce using rule 71 (unary_operation -> ? expr .)
    ,               reduce using rule 71 (unary_operation -> ? expr .)
    ELSE            reduce using rule 71 (unary_operation -> ? expr .)
    RIGHT_ASSIGN    shift and go to state 34
    [               shift and go to state 35
    LBB             shift and go to state 36
    +               shift and go to state 37
    -               shift and go to state 38
    *               shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 41
    INT_DIV         shift and go to state 42
    /               shift and go to state 43
    :               shift and go to state 44
    ~               shift and go to state 45
    LT              shift and go to state 47
    LE              shift and go to state 48
    EQ              shift and go to state 49
    NE              shift and go to state 50
    GE              shift and go to state 51
    GT              shift and go to state 52
    AND             shift and go to state 53
    OR              shift and go to state 54
    AND2            shift and go to state 55
    OR2             shift and go to state 56
    MATRIX_MULT     shift and go to state 57
    $               shift and go to state 58
    @               shift and go to state 59

  ! RIGHT_ASSIGN    [ reduce using rule 71 (unary_operation -> ? expr .) ]
  ! [               [ reduce using rule 71 (unary_operation -> ? expr .) ]
  ! LBB             [ reduce using rule 71 (unary_operation -> ? expr .) ]
  ! +               [ reduce using rule 71 (unary_operation -> ? expr .) ]
  ! -               [ reduce using rule 71 (unary_operation -> ? expr .) ]
  ! *               [ reduce using rule 71 (unary_operation -> ? expr .) ]
  ! POWER           [ reduce using rule 71 (unary_operation -> ? expr .) ]
  ! MOD             [ reduce using rule 71 (unary_operation -> ? expr .) ]
  ! INT_DIV         [ reduce using rule 71 (unary_operation -> ? expr .) ]
  ! /               [ reduce using rule 71 (unary_operation -> ? expr .) ]
  ! :               [ reduce using rule 71 (unary_operation -> ? expr .) ]
  ! ~               [ reduce using rule 71 (unary_operation -> ? expr .) ]
  ! LT              [ reduce using rule 71 (unary_operation -> ? expr .) ]
  ! LE              [ reduce using rule 71 (unary_operation -> ? expr .) ]
  ! EQ              [ reduce using rule 71 (unary_operation -> ? expr .) ]
  ! NE              [ reduce using rule 71 (unary_operation -> ? expr .) ]
  ! GE              [ reduce using rule 71 (unary_operation -> ? expr .) ]
  ! GT              [ reduce using rule 71 (unary_operation -> ? expr .) ]
  ! AND             [ reduce using rule 71 (unary_operation -> ? expr .) ]
  ! OR              [ reduce using rule 71 (unary_operation -> ? expr .) ]
  ! AND2            [ reduce using rule 71 (unary_operation -> ? expr .) ]
  ! OR2             [ reduce using rule 71 (unary_operation -> ? expr .) ]
  ! MATRIX_MULT     [ reduce using rule 71 (unary_operation -> ? expr .) ]
  ! $               [ reduce using rule 71 (unary_operation -> ? expr .) ]
  ! @               [ reduce using rule 71 (unary_operation -> ? expr .) ]
  ! ?               [ shift and go to state 46 ]


state 71

    (69) unary_operation -> ! expr .
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    RIGHT_ASSIGN    reduce using rule 69 (unary_operation -> ! expr .)
    ~               reduce using rule 69 (unary_operation -> ! expr .)
    ?               reduce using rule 69 (unary_operation -> ! expr .)
    AND             reduce using rule 69 (unary_operation -> ! expr .)
    OR              reduce using rule 69 (unary_operation -> ! expr .)
    AND2            reduce using rule 69 (unary_operation -> ! expr .)
    OR2             reduce using rule 69 (unary_operation -> ! expr .)
    ;               reduce using rule 69 (unary_operation -> ! expr .)
    NLINE           reduce using rule 69 (unary_operation -> ! expr .)
    $end            reduce using rule 69 (unary_operation -> ! expr .)
    )               reduce using rule 69 (unary_operation -> ! expr .)
    }               reduce using rule 69 (unary_operation -> ! expr .)
    ]               reduce using rule 69 (unary_operation -> ! expr .)
    ,               reduce using rule 69 (unary_operation -> ! expr .)
    ELSE            reduce using rule 69 (unary_operation -> ! expr .)
    [               shift and go to state 35
    LBB             shift and go to state 36
    +               shift and go to state 37
    -               shift and go to state 38
    *               shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 41
    INT_DIV         shift and go to state 42
    /               shift and go to state 43
    :               shift and go to state 44
    LT              shift and go to state 47
    LE              shift and go to state 48
    EQ              shift and go to state 49
    NE              shift and go to state 50
    GE              shift and go to state 51
    GT              shift and go to state 52
    MATRIX_MULT     shift and go to state 57
    $               shift and go to state 58
    @               shift and go to state 59

  ! [               [ reduce using rule 69 (unary_operation -> ! expr .) ]
  ! LBB             [ reduce using rule 69 (unary_operation -> ! expr .) ]
  ! +               [ reduce using rule 69 (unary_operation -> ! expr .) ]
  ! -               [ reduce using rule 69 (unary_operation -> ! expr .) ]
  ! *               [ reduce using rule 69 (unary_operation -> ! expr .) ]
  ! POWER           [ reduce using rule 69 (unary_operation -> ! expr .) ]
  ! MOD             [ reduce using rule 69 (unary_operation -> ! expr .) ]
  ! INT_DIV         [ reduce using rule 69 (unary_operation -> ! expr .) ]
  ! /               [ reduce using rule 69 (unary_operation -> ! expr .) ]
  ! :               [ reduce using rule 69 (unary_operation -> ! expr .) ]
  ! LT              [ reduce using rule 69 (unary_operation -> ! expr .) ]
  ! LE              [ reduce using rule 69 (unary_operation -> ! expr .) ]
  ! EQ              [ reduce using rule 69 (unary_operation -> ! expr .) ]
  ! NE              [ reduce using rule 69 (unary_operation -> ! expr .) ]
  ! GE              [ reduce using rule 69 (unary_operation -> ! expr .) ]
  ! GT              [ reduce using rule 69 (unary_operation -> ! expr .) ]
  ! MATRIX_MULT     [ reduce using rule 69 (unary_operation -> ! expr .) ]
  ! $               [ reduce using rule 69 (unary_operation -> ! expr .) ]
  ! @               [ reduce using rule 69 (unary_operation -> ! expr .) ]
  ! RIGHT_ASSIGN    [ shift and go to state 34 ]
  ! ~               [ shift and go to state 45 ]
  ! ?               [ shift and go to state 46 ]
  ! AND             [ shift and go to state 53 ]
  ! OR              [ shift and go to state 54 ]
  ! AND2            [ shift and go to state 55 ]
  ! OR2             [ shift and go to state 56 ]


state 72

    (75) if_statement -> IF ( . expr ) expr_or_assign_nl else_statement
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 117
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 73

    (79) for_statement -> FOR ( . SYMBOL IN expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 118


state 74

    (80) while_statement -> WHILE ( . expr ) expr_or_assign_nl
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 119
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 75

    (8) exprlist -> exprlist ; expr_or_assign .

    ;               reduce using rule 8 (exprlist -> exprlist ; expr_or_assign .)
    NLINE           reduce using rule 8 (exprlist -> exprlist ; expr_or_assign .)
    $end            reduce using rule 8 (exprlist -> exprlist ; expr_or_assign .)
    }               reduce using rule 8 (exprlist -> exprlist ; expr_or_assign .)


state 76

    (9) exprlist -> exprlist emptyline expr_or_assign .

    ;               reduce using rule 9 (exprlist -> exprlist emptyline expr_or_assign .)
    NLINE           reduce using rule 9 (exprlist -> exprlist emptyline expr_or_assign .)
    $end            reduce using rule 9 (exprlist -> exprlist emptyline expr_or_assign .)
    }               reduce using rule 9 (exprlist -> exprlist emptyline expr_or_assign .)


state 77

    (3) emptyline -> emptyline NLINE .

    NLINE           reduce using rule 3 (emptyline -> emptyline NLINE .)
    SYMBOL          reduce using rule 3 (emptyline -> emptyline NLINE .)
    (               reduce using rule 3 (emptyline -> emptyline NLINE .)
    {               reduce using rule 3 (emptyline -> emptyline NLINE .)
    FUNCTION        reduce using rule 3 (emptyline -> emptyline NLINE .)
    STR_CONST       reduce using rule 3 (emptyline -> emptyline NLINE .)
    REAL            reduce using rule 3 (emptyline -> emptyline NLINE .)
    INT             reduce using rule 3 (emptyline -> emptyline NLINE .)
    NULL_CONST      reduce using rule 3 (emptyline -> emptyline NLINE .)
    TRUE            reduce using rule 3 (emptyline -> emptyline NLINE .)
    FALSE           reduce using rule 3 (emptyline -> emptyline NLINE .)
    -               reduce using rule 3 (emptyline -> emptyline NLINE .)
    +               reduce using rule 3 (emptyline -> emptyline NLINE .)
    !               reduce using rule 3 (emptyline -> emptyline NLINE .)
    ~               reduce using rule 3 (emptyline -> emptyline NLINE .)
    ?               reduce using rule 3 (emptyline -> emptyline NLINE .)
    IF              reduce using rule 3 (emptyline -> emptyline NLINE .)
    FOR             reduce using rule 3 (emptyline -> emptyline NLINE .)
    WHILE           reduce using rule 3 (emptyline -> emptyline NLINE .)
    ;               reduce using rule 3 (emptyline -> emptyline NLINE .)
    $end            reduce using rule 3 (emptyline -> emptyline NLINE .)
    }               reduce using rule 3 (emptyline -> emptyline NLINE .)


state 78

    (18) expr -> expr RIGHT_ASSIGN SYMBOL .

    RIGHT_ASSIGN    reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    [               reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    LBB             reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    +               reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    -               reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    *               reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    POWER           reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    MOD             reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    INT_DIV         reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    /               reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    :               reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    ~               reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    ?               reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    LT              reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    LE              reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    EQ              reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    NE              reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    GE              reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    GT              reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    AND             reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    OR              reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    AND2            reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    OR2             reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    MATRIX_MULT     reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    $               reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    @               reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    ;               reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    NLINE           reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    $end            reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    )               reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    }               reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    ]               reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    ,               reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)
    ELSE            reduce using rule 18 (expr -> expr RIGHT_ASSIGN SYMBOL .)


state 79

    (34) sub -> expr .
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    ]               reduce using rule 34 (sub -> expr .)
    ,               reduce using rule 34 (sub -> expr .)
    )               reduce using rule 34 (sub -> expr .)
    RIGHT_ASSIGN    shift and go to state 34
    [               shift and go to state 35
    LBB             shift and go to state 36
    +               shift and go to state 37
    -               shift and go to state 38
    *               shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 41
    INT_DIV         shift and go to state 42
    /               shift and go to state 43
    :               shift and go to state 44
    ~               shift and go to state 45
    ?               shift and go to state 46
    LT              shift and go to state 47
    LE              shift and go to state 48
    EQ              shift and go to state 49
    NE              shift and go to state 50
    GE              shift and go to state 51
    GT              shift and go to state 52
    AND             shift and go to state 53
    OR              shift and go to state 54
    AND2            shift and go to state 55
    OR2             shift and go to state 56
    MATRIX_MULT     shift and go to state 57
    $               shift and go to state 58
    @               shift and go to state 59


state 80

    (21) expr -> expr [ sublist . ]
    (32) sublist -> sublist . , sub

    ]               shift and go to state 120
    ,               shift and go to state 121


state 81

    (31) sublist -> sub .

    ]               reduce using rule 31 (sublist -> sub .)
    ,               reduce using rule 31 (sublist -> sub .)
    )               reduce using rule 31 (sublist -> sub .)


state 82

    (33) sub -> empty .

    ]               reduce using rule 33 (sub -> empty .)
    ,               reduce using rule 33 (sub -> empty .)
    )               reduce using rule 33 (sub -> empty .)


state 83

    (22) expr -> expr LBB sublist . ] ]
    (32) sublist -> sublist . , sub

    ]               shift and go to state 122
    ,               shift and go to state 121


state 84

    (42) binary_operation -> expr + expr .
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    RIGHT_ASSIGN    reduce using rule 42 (binary_operation -> expr + expr .)
    +               reduce using rule 42 (binary_operation -> expr + expr .)
    -               reduce using rule 42 (binary_operation -> expr + expr .)
    ~               reduce using rule 42 (binary_operation -> expr + expr .)
    ?               reduce using rule 42 (binary_operation -> expr + expr .)
    LT              reduce using rule 42 (binary_operation -> expr + expr .)
    LE              reduce using rule 42 (binary_operation -> expr + expr .)
    EQ              reduce using rule 42 (binary_operation -> expr + expr .)
    NE              reduce using rule 42 (binary_operation -> expr + expr .)
    GE              reduce using rule 42 (binary_operation -> expr + expr .)
    GT              reduce using rule 42 (binary_operation -> expr + expr .)
    AND             reduce using rule 42 (binary_operation -> expr + expr .)
    OR              reduce using rule 42 (binary_operation -> expr + expr .)
    AND2            reduce using rule 42 (binary_operation -> expr + expr .)
    OR2             reduce using rule 42 (binary_operation -> expr + expr .)
    ;               reduce using rule 42 (binary_operation -> expr + expr .)
    NLINE           reduce using rule 42 (binary_operation -> expr + expr .)
    $end            reduce using rule 42 (binary_operation -> expr + expr .)
    )               reduce using rule 42 (binary_operation -> expr + expr .)
    }               reduce using rule 42 (binary_operation -> expr + expr .)
    ]               reduce using rule 42 (binary_operation -> expr + expr .)
    ,               reduce using rule 42 (binary_operation -> expr + expr .)
    ELSE            reduce using rule 42 (binary_operation -> expr + expr .)
    [               shift and go to state 35
    LBB             shift and go to state 36
    *               shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 41
    INT_DIV         shift and go to state 42
    /               shift and go to state 43
    :               shift and go to state 44
    MATRIX_MULT     shift and go to state 57
    $               shift and go to state 58
    @               shift and go to state 59

  ! [               [ reduce using rule 42 (binary_operation -> expr + expr .) ]
  ! LBB             [ reduce using rule 42 (binary_operation -> expr + expr .) ]
  ! *               [ reduce using rule 42 (binary_operation -> expr + expr .) ]
  ! POWER           [ reduce using rule 42 (binary_operation -> expr + expr .) ]
  ! MOD             [ reduce using rule 42 (binary_operation -> expr + expr .) ]
  ! INT_DIV         [ reduce using rule 42 (binary_operation -> expr + expr .) ]
  ! /               [ reduce using rule 42 (binary_operation -> expr + expr .) ]
  ! :               [ reduce using rule 42 (binary_operation -> expr + expr .) ]
  ! MATRIX_MULT     [ reduce using rule 42 (binary_operation -> expr + expr .) ]
  ! $               [ reduce using rule 42 (binary_operation -> expr + expr .) ]
  ! @               [ reduce using rule 42 (binary_operation -> expr + expr .) ]
  ! RIGHT_ASSIGN    [ shift and go to state 34 ]
  ! +               [ shift and go to state 37 ]
  ! -               [ shift and go to state 38 ]
  ! ~               [ shift and go to state 45 ]
  ! ?               [ shift and go to state 46 ]
  ! LT              [ shift and go to state 47 ]
  ! LE              [ shift and go to state 48 ]
  ! EQ              [ shift and go to state 49 ]
  ! NE              [ shift and go to state 50 ]
  ! GE              [ shift and go to state 51 ]
  ! GT              [ shift and go to state 52 ]
  ! AND             [ shift and go to state 53 ]
  ! OR              [ shift and go to state 54 ]
  ! AND2            [ shift and go to state 55 ]
  ! OR2             [ shift and go to state 56 ]


state 85

    (43) binary_operation -> expr - expr .
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    RIGHT_ASSIGN    reduce using rule 43 (binary_operation -> expr - expr .)
    +               reduce using rule 43 (binary_operation -> expr - expr .)
    -               reduce using rule 43 (binary_operation -> expr - expr .)
    ~               reduce using rule 43 (binary_operation -> expr - expr .)
    ?               reduce using rule 43 (binary_operation -> expr - expr .)
    LT              reduce using rule 43 (binary_operation -> expr - expr .)
    LE              reduce using rule 43 (binary_operation -> expr - expr .)
    EQ              reduce using rule 43 (binary_operation -> expr - expr .)
    NE              reduce using rule 43 (binary_operation -> expr - expr .)
    GE              reduce using rule 43 (binary_operation -> expr - expr .)
    GT              reduce using rule 43 (binary_operation -> expr - expr .)
    AND             reduce using rule 43 (binary_operation -> expr - expr .)
    OR              reduce using rule 43 (binary_operation -> expr - expr .)
    AND2            reduce using rule 43 (binary_operation -> expr - expr .)
    OR2             reduce using rule 43 (binary_operation -> expr - expr .)
    ;               reduce using rule 43 (binary_operation -> expr - expr .)
    NLINE           reduce using rule 43 (binary_operation -> expr - expr .)
    $end            reduce using rule 43 (binary_operation -> expr - expr .)
    )               reduce using rule 43 (binary_operation -> expr - expr .)
    }               reduce using rule 43 (binary_operation -> expr - expr .)
    ]               reduce using rule 43 (binary_operation -> expr - expr .)
    ,               reduce using rule 43 (binary_operation -> expr - expr .)
    ELSE            reduce using rule 43 (binary_operation -> expr - expr .)
    [               shift and go to state 35
    LBB             shift and go to state 36
    *               shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 41
    INT_DIV         shift and go to state 42
    /               shift and go to state 43
    :               shift and go to state 44
    MATRIX_MULT     shift and go to state 57
    $               shift and go to state 58
    @               shift and go to state 59

  ! [               [ reduce using rule 43 (binary_operation -> expr - expr .) ]
  ! LBB             [ reduce using rule 43 (binary_operation -> expr - expr .) ]
  ! *               [ reduce using rule 43 (binary_operation -> expr - expr .) ]
  ! POWER           [ reduce using rule 43 (binary_operation -> expr - expr .) ]
  ! MOD             [ reduce using rule 43 (binary_operation -> expr - expr .) ]
  ! INT_DIV         [ reduce using rule 43 (binary_operation -> expr - expr .) ]
  ! /               [ reduce using rule 43 (binary_operation -> expr - expr .) ]
  ! :               [ reduce using rule 43 (binary_operation -> expr - expr .) ]
  ! MATRIX_MULT     [ reduce using rule 43 (binary_operation -> expr - expr .) ]
  ! $               [ reduce using rule 43 (binary_operation -> expr - expr .) ]
  ! @               [ reduce using rule 43 (binary_operation -> expr - expr .) ]
  ! RIGHT_ASSIGN    [ shift and go to state 34 ]
  ! +               [ shift and go to state 37 ]
  ! -               [ shift and go to state 38 ]
  ! ~               [ shift and go to state 45 ]
  ! ?               [ shift and go to state 46 ]
  ! LT              [ shift and go to state 47 ]
  ! LE              [ shift and go to state 48 ]
  ! EQ              [ shift and go to state 49 ]
  ! NE              [ shift and go to state 50 ]
  ! GE              [ shift and go to state 51 ]
  ! GT              [ shift and go to state 52 ]
  ! AND             [ shift and go to state 53 ]
  ! OR              [ shift and go to state 54 ]
  ! AND2            [ shift and go to state 55 ]
  ! OR2             [ shift and go to state 56 ]


state 86

    (44) binary_operation -> expr * expr .
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    RIGHT_ASSIGN    reduce using rule 44 (binary_operation -> expr * expr .)
    +               reduce using rule 44 (binary_operation -> expr * expr .)
    -               reduce using rule 44 (binary_operation -> expr * expr .)
    *               reduce using rule 44 (binary_operation -> expr * expr .)
    /               reduce using rule 44 (binary_operation -> expr * expr .)
    ~               reduce using rule 44 (binary_operation -> expr * expr .)
    ?               reduce using rule 44 (binary_operation -> expr * expr .)
    LT              reduce using rule 44 (binary_operation -> expr * expr .)
    LE              reduce using rule 44 (binary_operation -> expr * expr .)
    EQ              reduce using rule 44 (binary_operation -> expr * expr .)
    NE              reduce using rule 44 (binary_operation -> expr * expr .)
    GE              reduce using rule 44 (binary_operation -> expr * expr .)
    GT              reduce using rule 44 (binary_operation -> expr * expr .)
    AND             reduce using rule 44 (binary_operation -> expr * expr .)
    OR              reduce using rule 44 (binary_operation -> expr * expr .)
    AND2            reduce using rule 44 (binary_operation -> expr * expr .)
    OR2             reduce using rule 44 (binary_operation -> expr * expr .)
    ;               reduce using rule 44 (binary_operation -> expr * expr .)
    NLINE           reduce using rule 44 (binary_operation -> expr * expr .)
    $end            reduce using rule 44 (binary_operation -> expr * expr .)
    )               reduce using rule 44 (binary_operation -> expr * expr .)
    }               reduce using rule 44 (binary_operation -> expr * expr .)
    ]               reduce using rule 44 (binary_operation -> expr * expr .)
    ,               reduce using rule 44 (binary_operation -> expr * expr .)
    ELSE            reduce using rule 44 (binary_operation -> expr * expr .)
    [               shift and go to state 35
    LBB             shift and go to state 36
    POWER           shift and go to state 40
    MOD             shift and go to state 41
    INT_DIV         shift and go to state 42
    :               shift and go to state 44
    MATRIX_MULT     shift and go to state 57
    $               shift and go to state 58
    @               shift and go to state 59

  ! [               [ reduce using rule 44 (binary_operation -> expr * expr .) ]
  ! LBB             [ reduce using rule 44 (binary_operation -> expr * expr .) ]
  ! POWER           [ reduce using rule 44 (binary_operation -> expr * expr .) ]
  ! MOD             [ reduce using rule 44 (binary_operation -> expr * expr .) ]
  ! INT_DIV         [ reduce using rule 44 (binary_operation -> expr * expr .) ]
  ! :               [ reduce using rule 44 (binary_operation -> expr * expr .) ]
  ! MATRIX_MULT     [ reduce using rule 44 (binary_operation -> expr * expr .) ]
  ! $               [ reduce using rule 44 (binary_operation -> expr * expr .) ]
  ! @               [ reduce using rule 44 (binary_operation -> expr * expr .) ]
  ! RIGHT_ASSIGN    [ shift and go to state 34 ]
  ! +               [ shift and go to state 37 ]
  ! -               [ shift and go to state 38 ]
  ! *               [ shift and go to state 39 ]
  ! /               [ shift and go to state 43 ]
  ! ~               [ shift and go to state 45 ]
  ! ?               [ shift and go to state 46 ]
  ! LT              [ shift and go to state 47 ]
  ! LE              [ shift and go to state 48 ]
  ! EQ              [ shift and go to state 49 ]
  ! NE              [ shift and go to state 50 ]
  ! GE              [ shift and go to state 51 ]
  ! GT              [ shift and go to state 52 ]
  ! AND             [ shift and go to state 53 ]
  ! OR              [ shift and go to state 54 ]
  ! AND2            [ shift and go to state 55 ]
  ! OR2             [ shift and go to state 56 ]


state 87

    (45) binary_operation -> expr POWER expr .
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    RIGHT_ASSIGN    reduce using rule 45 (binary_operation -> expr POWER expr .)
    +               reduce using rule 45 (binary_operation -> expr POWER expr .)
    -               reduce using rule 45 (binary_operation -> expr POWER expr .)
    *               reduce using rule 45 (binary_operation -> expr POWER expr .)
    MOD             reduce using rule 45 (binary_operation -> expr POWER expr .)
    INT_DIV         reduce using rule 45 (binary_operation -> expr POWER expr .)
    /               reduce using rule 45 (binary_operation -> expr POWER expr .)
    :               reduce using rule 45 (binary_operation -> expr POWER expr .)
    ~               reduce using rule 45 (binary_operation -> expr POWER expr .)
    ?               reduce using rule 45 (binary_operation -> expr POWER expr .)
    LT              reduce using rule 45 (binary_operation -> expr POWER expr .)
    LE              reduce using rule 45 (binary_operation -> expr POWER expr .)
    EQ              reduce using rule 45 (binary_operation -> expr POWER expr .)
    NE              reduce using rule 45 (binary_operation -> expr POWER expr .)
    GE              reduce using rule 45 (binary_operation -> expr POWER expr .)
    GT              reduce using rule 45 (binary_operation -> expr POWER expr .)
    AND             reduce using rule 45 (binary_operation -> expr POWER expr .)
    OR              reduce using rule 45 (binary_operation -> expr POWER expr .)
    AND2            reduce using rule 45 (binary_operation -> expr POWER expr .)
    OR2             reduce using rule 45 (binary_operation -> expr POWER expr .)
    MATRIX_MULT     reduce using rule 45 (binary_operation -> expr POWER expr .)
    ;               reduce using rule 45 (binary_operation -> expr POWER expr .)
    NLINE           reduce using rule 45 (binary_operation -> expr POWER expr .)
    $end            reduce using rule 45 (binary_operation -> expr POWER expr .)
    )               reduce using rule 45 (binary_operation -> expr POWER expr .)
    }               reduce using rule 45 (binary_operation -> expr POWER expr .)
    ]               reduce using rule 45 (binary_operation -> expr POWER expr .)
    ,               reduce using rule 45 (binary_operation -> expr POWER expr .)
    ELSE            reduce using rule 45 (binary_operation -> expr POWER expr .)
    [               shift and go to state 35
    LBB             shift and go to state 36
    POWER           shift and go to state 40
    $               shift and go to state 58
    @               shift and go to state 59

  ! [               [ reduce using rule 45 (binary_operation -> expr POWER expr .) ]
  ! LBB             [ reduce using rule 45 (binary_operation -> expr POWER expr .) ]
  ! POWER           [ reduce using rule 45 (binary_operation -> expr POWER expr .) ]
  ! $               [ reduce using rule 45 (binary_operation -> expr POWER expr .) ]
  ! @               [ reduce using rule 45 (binary_operation -> expr POWER expr .) ]
  ! RIGHT_ASSIGN    [ shift and go to state 34 ]
  ! +               [ shift and go to state 37 ]
  ! -               [ shift and go to state 38 ]
  ! *               [ shift and go to state 39 ]
  ! MOD             [ shift and go to state 41 ]
  ! INT_DIV         [ shift and go to state 42 ]
  ! /               [ shift and go to state 43 ]
  ! :               [ shift and go to state 44 ]
  ! ~               [ shift and go to state 45 ]
  ! ?               [ shift and go to state 46 ]
  ! LT              [ shift and go to state 47 ]
  ! LE              [ shift and go to state 48 ]
  ! EQ              [ shift and go to state 49 ]
  ! NE              [ shift and go to state 50 ]
  ! GE              [ shift and go to state 51 ]
  ! GT              [ shift and go to state 52 ]
  ! AND             [ shift and go to state 53 ]
  ! OR              [ shift and go to state 54 ]
  ! AND2            [ shift and go to state 55 ]
  ! OR2             [ shift and go to state 56 ]
  ! MATRIX_MULT     [ shift and go to state 57 ]


state 88

    (46) binary_operation -> expr MOD expr .
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    RIGHT_ASSIGN    reduce using rule 46 (binary_operation -> expr MOD expr .)
    +               reduce using rule 46 (binary_operation -> expr MOD expr .)
    -               reduce using rule 46 (binary_operation -> expr MOD expr .)
    *               reduce using rule 46 (binary_operation -> expr MOD expr .)
    MOD             reduce using rule 46 (binary_operation -> expr MOD expr .)
    INT_DIV         reduce using rule 46 (binary_operation -> expr MOD expr .)
    /               reduce using rule 46 (binary_operation -> expr MOD expr .)
    ~               reduce using rule 46 (binary_operation -> expr MOD expr .)
    ?               reduce using rule 46 (binary_operation -> expr MOD expr .)
    LT              reduce using rule 46 (binary_operation -> expr MOD expr .)
    LE              reduce using rule 46 (binary_operation -> expr MOD expr .)
    EQ              reduce using rule 46 (binary_operation -> expr MOD expr .)
    NE              reduce using rule 46 (binary_operation -> expr MOD expr .)
    GE              reduce using rule 46 (binary_operation -> expr MOD expr .)
    GT              reduce using rule 46 (binary_operation -> expr MOD expr .)
    AND             reduce using rule 46 (binary_operation -> expr MOD expr .)
    OR              reduce using rule 46 (binary_operation -> expr MOD expr .)
    AND2            reduce using rule 46 (binary_operation -> expr MOD expr .)
    OR2             reduce using rule 46 (binary_operation -> expr MOD expr .)
    MATRIX_MULT     reduce using rule 46 (binary_operation -> expr MOD expr .)
    ;               reduce using rule 46 (binary_operation -> expr MOD expr .)
    NLINE           reduce using rule 46 (binary_operation -> expr MOD expr .)
    $end            reduce using rule 46 (binary_operation -> expr MOD expr .)
    )               reduce using rule 46 (binary_operation -> expr MOD expr .)
    }               reduce using rule 46 (binary_operation -> expr MOD expr .)
    ]               reduce using rule 46 (binary_operation -> expr MOD expr .)
    ,               reduce using rule 46 (binary_operation -> expr MOD expr .)
    ELSE            reduce using rule 46 (binary_operation -> expr MOD expr .)
    [               shift and go to state 35
    LBB             shift and go to state 36
    POWER           shift and go to state 40
    :               shift and go to state 44
    $               shift and go to state 58
    @               shift and go to state 59

  ! [               [ reduce using rule 46 (binary_operation -> expr MOD expr .) ]
  ! LBB             [ reduce using rule 46 (binary_operation -> expr MOD expr .) ]
  ! POWER           [ reduce using rule 46 (binary_operation -> expr MOD expr .) ]
  ! :               [ reduce using rule 46 (binary_operation -> expr MOD expr .) ]
  ! $               [ reduce using rule 46 (binary_operation -> expr MOD expr .) ]
  ! @               [ reduce using rule 46 (binary_operation -> expr MOD expr .) ]
  ! RIGHT_ASSIGN    [ shift and go to state 34 ]
  ! +               [ shift and go to state 37 ]
  ! -               [ shift and go to state 38 ]
  ! *               [ shift and go to state 39 ]
  ! MOD             [ shift and go to state 41 ]
  ! INT_DIV         [ shift and go to state 42 ]
  ! /               [ shift and go to state 43 ]
  ! ~               [ shift and go to state 45 ]
  ! ?               [ shift and go to state 46 ]
  ! LT              [ shift and go to state 47 ]
  ! LE              [ shift and go to state 48 ]
  ! EQ              [ shift and go to state 49 ]
  ! NE              [ shift and go to state 50 ]
  ! GE              [ shift and go to state 51 ]
  ! GT              [ shift and go to state 52 ]
  ! AND             [ shift and go to state 53 ]
  ! OR              [ shift and go to state 54 ]
  ! AND2            [ shift and go to state 55 ]
  ! OR2             [ shift and go to state 56 ]
  ! MATRIX_MULT     [ shift and go to state 57 ]


state 89

    (47) binary_operation -> expr INT_DIV expr .
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    RIGHT_ASSIGN    reduce using rule 47 (binary_operation -> expr INT_DIV expr .)
    +               reduce using rule 47 (binary_operation -> expr INT_DIV expr .)
    -               reduce using rule 47 (binary_operation -> expr INT_DIV expr .)
    *               reduce using rule 47 (binary_operation -> expr INT_DIV expr .)
    MOD             reduce using rule 47 (binary_operation -> expr INT_DIV expr .)
    INT_DIV         reduce using rule 47 (binary_operation -> expr INT_DIV expr .)
    /               reduce using rule 47 (binary_operation -> expr INT_DIV expr .)
    ~               reduce using rule 47 (binary_operation -> expr INT_DIV expr .)
    ?               reduce using rule 47 (binary_operation -> expr INT_DIV expr .)
    LT              reduce using rule 47 (binary_operation -> expr INT_DIV expr .)
    LE              reduce using rule 47 (binary_operation -> expr INT_DIV expr .)
    EQ              reduce using rule 47 (binary_operation -> expr INT_DIV expr .)
    NE              reduce using rule 47 (binary_operation -> expr INT_DIV expr .)
    GE              reduce using rule 47 (binary_operation -> expr INT_DIV expr .)
    GT              reduce using rule 47 (binary_operation -> expr INT_DIV expr .)
    AND             reduce using rule 47 (binary_operation -> expr INT_DIV expr .)
    OR              reduce using rule 47 (binary_operation -> expr INT_DIV expr .)
    AND2            reduce using rule 47 (binary_operation -> expr INT_DIV expr .)
    OR2             reduce using rule 47 (binary_operation -> expr INT_DIV expr .)
    MATRIX_MULT     reduce using rule 47 (binary_operation -> expr INT_DIV expr .)
    ;               reduce using rule 47 (binary_operation -> expr INT_DIV expr .)
    NLINE           reduce using rule 47 (binary_operation -> expr INT_DIV expr .)
    $end            reduce using rule 47 (binary_operation -> expr INT_DIV expr .)
    )               reduce using rule 47 (binary_operation -> expr INT_DIV expr .)
    }               reduce using rule 47 (binary_operation -> expr INT_DIV expr .)
    ]               reduce using rule 47 (binary_operation -> expr INT_DIV expr .)
    ,               reduce using rule 47 (binary_operation -> expr INT_DIV expr .)
    ELSE            reduce using rule 47 (binary_operation -> expr INT_DIV expr .)
    [               shift and go to state 35
    LBB             shift and go to state 36
    POWER           shift and go to state 40
    :               shift and go to state 44
    $               shift and go to state 58
    @               shift and go to state 59

  ! [               [ reduce using rule 47 (binary_operation -> expr INT_DIV expr .) ]
  ! LBB             [ reduce using rule 47 (binary_operation -> expr INT_DIV expr .) ]
  ! POWER           [ reduce using rule 47 (binary_operation -> expr INT_DIV expr .) ]
  ! :               [ reduce using rule 47 (binary_operation -> expr INT_DIV expr .) ]
  ! $               [ reduce using rule 47 (binary_operation -> expr INT_DIV expr .) ]
  ! @               [ reduce using rule 47 (binary_operation -> expr INT_DIV expr .) ]
  ! RIGHT_ASSIGN    [ shift and go to state 34 ]
  ! +               [ shift and go to state 37 ]
  ! -               [ shift and go to state 38 ]
  ! *               [ shift and go to state 39 ]
  ! MOD             [ shift and go to state 41 ]
  ! INT_DIV         [ shift and go to state 42 ]
  ! /               [ shift and go to state 43 ]
  ! ~               [ shift and go to state 45 ]
  ! ?               [ shift and go to state 46 ]
  ! LT              [ shift and go to state 47 ]
  ! LE              [ shift and go to state 48 ]
  ! EQ              [ shift and go to state 49 ]
  ! NE              [ shift and go to state 50 ]
  ! GE              [ shift and go to state 51 ]
  ! GT              [ shift and go to state 52 ]
  ! AND             [ shift and go to state 53 ]
  ! OR              [ shift and go to state 54 ]
  ! AND2            [ shift and go to state 55 ]
  ! OR2             [ shift and go to state 56 ]
  ! MATRIX_MULT     [ shift and go to state 57 ]


state 90

    (48) binary_operation -> expr / expr .
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    RIGHT_ASSIGN    reduce using rule 48 (binary_operation -> expr / expr .)
    +               reduce using rule 48 (binary_operation -> expr / expr .)
    -               reduce using rule 48 (binary_operation -> expr / expr .)
    *               reduce using rule 48 (binary_operation -> expr / expr .)
    /               reduce using rule 48 (binary_operation -> expr / expr .)
    ~               reduce using rule 48 (binary_operation -> expr / expr .)
    ?               reduce using rule 48 (binary_operation -> expr / expr .)
    LT              reduce using rule 48 (binary_operation -> expr / expr .)
    LE              reduce using rule 48 (binary_operation -> expr / expr .)
    EQ              reduce using rule 48 (binary_operation -> expr / expr .)
    NE              reduce using rule 48 (binary_operation -> expr / expr .)
    GE              reduce using rule 48 (binary_operation -> expr / expr .)
    GT              reduce using rule 48 (binary_operation -> expr / expr .)
    AND             reduce using rule 48 (binary_operation -> expr / expr .)
    OR              reduce using rule 48 (binary_operation -> expr / expr .)
    AND2            reduce using rule 48 (binary_operation -> expr / expr .)
    OR2             reduce using rule 48 (binary_operation -> expr / expr .)
    ;               reduce using rule 48 (binary_operation -> expr / expr .)
    NLINE           reduce using rule 48 (binary_operation -> expr / expr .)
    $end            reduce using rule 48 (binary_operation -> expr / expr .)
    )               reduce using rule 48 (binary_operation -> expr / expr .)
    }               reduce using rule 48 (binary_operation -> expr / expr .)
    ]               reduce using rule 48 (binary_operation -> expr / expr .)
    ,               reduce using rule 48 (binary_operation -> expr / expr .)
    ELSE            reduce using rule 48 (binary_operation -> expr / expr .)
    [               shift and go to state 35
    LBB             shift and go to state 36
    POWER           shift and go to state 40
    MOD             shift and go to state 41
    INT_DIV         shift and go to state 42
    :               shift and go to state 44
    MATRIX_MULT     shift and go to state 57
    $               shift and go to state 58
    @               shift and go to state 59

  ! [               [ reduce using rule 48 (binary_operation -> expr / expr .) ]
  ! LBB             [ reduce using rule 48 (binary_operation -> expr / expr .) ]
  ! POWER           [ reduce using rule 48 (binary_operation -> expr / expr .) ]
  ! MOD             [ reduce using rule 48 (binary_operation -> expr / expr .) ]
  ! INT_DIV         [ reduce using rule 48 (binary_operation -> expr / expr .) ]
  ! :               [ reduce using rule 48 (binary_operation -> expr / expr .) ]
  ! MATRIX_MULT     [ reduce using rule 48 (binary_operation -> expr / expr .) ]
  ! $               [ reduce using rule 48 (binary_operation -> expr / expr .) ]
  ! @               [ reduce using rule 48 (binary_operation -> expr / expr .) ]
  ! RIGHT_ASSIGN    [ shift and go to state 34 ]
  ! +               [ shift and go to state 37 ]
  ! -               [ shift and go to state 38 ]
  ! *               [ shift and go to state 39 ]
  ! /               [ shift and go to state 43 ]
  ! ~               [ shift and go to state 45 ]
  ! ?               [ shift and go to state 46 ]
  ! LT              [ shift and go to state 47 ]
  ! LE              [ shift and go to state 48 ]
  ! EQ              [ shift and go to state 49 ]
  ! NE              [ shift and go to state 50 ]
  ! GE              [ shift and go to state 51 ]
  ! GT              [ shift and go to state 52 ]
  ! AND             [ shift and go to state 53 ]
  ! OR              [ shift and go to state 54 ]
  ! AND2            [ shift and go to state 55 ]
  ! OR2             [ shift and go to state 56 ]


state 91

    (49) binary_operation -> expr : expr .
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    RIGHT_ASSIGN    reduce using rule 49 (binary_operation -> expr : expr .)
    +               reduce using rule 49 (binary_operation -> expr : expr .)
    -               reduce using rule 49 (binary_operation -> expr : expr .)
    *               reduce using rule 49 (binary_operation -> expr : expr .)
    MOD             reduce using rule 49 (binary_operation -> expr : expr .)
    INT_DIV         reduce using rule 49 (binary_operation -> expr : expr .)
    /               reduce using rule 49 (binary_operation -> expr : expr .)
    :               reduce using rule 49 (binary_operation -> expr : expr .)
    ~               reduce using rule 49 (binary_operation -> expr : expr .)
    ?               reduce using rule 49 (binary_operation -> expr : expr .)
    LT              reduce using rule 49 (binary_operation -> expr : expr .)
    LE              reduce using rule 49 (binary_operation -> expr : expr .)
    EQ              reduce using rule 49 (binary_operation -> expr : expr .)
    NE              reduce using rule 49 (binary_operation -> expr : expr .)
    GE              reduce using rule 49 (binary_operation -> expr : expr .)
    GT              reduce using rule 49 (binary_operation -> expr : expr .)
    AND             reduce using rule 49 (binary_operation -> expr : expr .)
    OR              reduce using rule 49 (binary_operation -> expr : expr .)
    AND2            reduce using rule 49 (binary_operation -> expr : expr .)
    OR2             reduce using rule 49 (binary_operation -> expr : expr .)
    MATRIX_MULT     reduce using rule 49 (binary_operation -> expr : expr .)
    ;               reduce using rule 49 (binary_operation -> expr : expr .)
    NLINE           reduce using rule 49 (binary_operation -> expr : expr .)
    $end            reduce using rule 49 (binary_operation -> expr : expr .)
    )               reduce using rule 49 (binary_operation -> expr : expr .)
    }               reduce using rule 49 (binary_operation -> expr : expr .)
    ]               reduce using rule 49 (binary_operation -> expr : expr .)
    ,               reduce using rule 49 (binary_operation -> expr : expr .)
    ELSE            reduce using rule 49 (binary_operation -> expr : expr .)
    [               shift and go to state 35
    LBB             shift and go to state 36
    POWER           shift and go to state 40
    $               shift and go to state 58
    @               shift and go to state 59

  ! [               [ reduce using rule 49 (binary_operation -> expr : expr .) ]
  ! LBB             [ reduce using rule 49 (binary_operation -> expr : expr .) ]
  ! POWER           [ reduce using rule 49 (binary_operation -> expr : expr .) ]
  ! $               [ reduce using rule 49 (binary_operation -> expr : expr .) ]
  ! @               [ reduce using rule 49 (binary_operation -> expr : expr .) ]
  ! RIGHT_ASSIGN    [ shift and go to state 34 ]
  ! +               [ shift and go to state 37 ]
  ! -               [ shift and go to state 38 ]
  ! *               [ shift and go to state 39 ]
  ! MOD             [ shift and go to state 41 ]
  ! INT_DIV         [ shift and go to state 42 ]
  ! /               [ shift and go to state 43 ]
  ! :               [ shift and go to state 44 ]
  ! ~               [ shift and go to state 45 ]
  ! ?               [ shift and go to state 46 ]
  ! LT              [ shift and go to state 47 ]
  ! LE              [ shift and go to state 48 ]
  ! EQ              [ shift and go to state 49 ]
  ! NE              [ shift and go to state 50 ]
  ! GE              [ shift and go to state 51 ]
  ! GT              [ shift and go to state 52 ]
  ! AND             [ shift and go to state 53 ]
  ! OR              [ shift and go to state 54 ]
  ! AND2            [ shift and go to state 55 ]
  ! OR2             [ shift and go to state 56 ]
  ! MATRIX_MULT     [ shift and go to state 57 ]


state 92

    (50) binary_operation -> expr ~ expr .
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    RIGHT_ASSIGN    reduce using rule 50 (binary_operation -> expr ~ expr .)
    ~               reduce using rule 50 (binary_operation -> expr ~ expr .)
    ?               reduce using rule 50 (binary_operation -> expr ~ expr .)
    ;               reduce using rule 50 (binary_operation -> expr ~ expr .)
    NLINE           reduce using rule 50 (binary_operation -> expr ~ expr .)
    $end            reduce using rule 50 (binary_operation -> expr ~ expr .)
    )               reduce using rule 50 (binary_operation -> expr ~ expr .)
    }               reduce using rule 50 (binary_operation -> expr ~ expr .)
    ]               reduce using rule 50 (binary_operation -> expr ~ expr .)
    ,               reduce using rule 50 (binary_operation -> expr ~ expr .)
    ELSE            reduce using rule 50 (binary_operation -> expr ~ expr .)
    [               shift and go to state 35
    LBB             shift and go to state 36
    +               shift and go to state 37
    -               shift and go to state 38
    *               shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 41
    INT_DIV         shift and go to state 42
    /               shift and go to state 43
    :               shift and go to state 44
    LT              shift and go to state 47
    LE              shift and go to state 48
    EQ              shift and go to state 49
    NE              shift and go to state 50
    GE              shift and go to state 51
    GT              shift and go to state 52
    AND             shift and go to state 53
    OR              shift and go to state 54
    AND2            shift and go to state 55
    OR2             shift and go to state 56
    MATRIX_MULT     shift and go to state 57
    $               shift and go to state 58
    @               shift and go to state 59

  ! [               [ reduce using rule 50 (binary_operation -> expr ~ expr .) ]
  ! LBB             [ reduce using rule 50 (binary_operation -> expr ~ expr .) ]
  ! +               [ reduce using rule 50 (binary_operation -> expr ~ expr .) ]
  ! -               [ reduce using rule 50 (binary_operation -> expr ~ expr .) ]
  ! *               [ reduce using rule 50 (binary_operation -> expr ~ expr .) ]
  ! POWER           [ reduce using rule 50 (binary_operation -> expr ~ expr .) ]
  ! MOD             [ reduce using rule 50 (binary_operation -> expr ~ expr .) ]
  ! INT_DIV         [ reduce using rule 50 (binary_operation -> expr ~ expr .) ]
  ! /               [ reduce using rule 50 (binary_operation -> expr ~ expr .) ]
  ! :               [ reduce using rule 50 (binary_operation -> expr ~ expr .) ]
  ! LT              [ reduce using rule 50 (binary_operation -> expr ~ expr .) ]
  ! LE              [ reduce using rule 50 (binary_operation -> expr ~ expr .) ]
  ! EQ              [ reduce using rule 50 (binary_operation -> expr ~ expr .) ]
  ! NE              [ reduce using rule 50 (binary_operation -> expr ~ expr .) ]
  ! GE              [ reduce using rule 50 (binary_operation -> expr ~ expr .) ]
  ! GT              [ reduce using rule 50 (binary_operation -> expr ~ expr .) ]
  ! AND             [ reduce using rule 50 (binary_operation -> expr ~ expr .) ]
  ! OR              [ reduce using rule 50 (binary_operation -> expr ~ expr .) ]
  ! AND2            [ reduce using rule 50 (binary_operation -> expr ~ expr .) ]
  ! OR2             [ reduce using rule 50 (binary_operation -> expr ~ expr .) ]
  ! MATRIX_MULT     [ reduce using rule 50 (binary_operation -> expr ~ expr .) ]
  ! $               [ reduce using rule 50 (binary_operation -> expr ~ expr .) ]
  ! @               [ reduce using rule 50 (binary_operation -> expr ~ expr .) ]
  ! RIGHT_ASSIGN    [ shift and go to state 34 ]
  ! ~               [ shift and go to state 45 ]
  ! ?               [ shift and go to state 46 ]


state 93

    (51) binary_operation -> expr ? expr .
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    ?               reduce using rule 51 (binary_operation -> expr ? expr .)
    ;               reduce using rule 51 (binary_operation -> expr ? expr .)
    NLINE           reduce using rule 51 (binary_operation -> expr ? expr .)
    $end            reduce using rule 51 (binary_operation -> expr ? expr .)
    )               reduce using rule 51 (binary_operation -> expr ? expr .)
    }               reduce using rule 51 (binary_operation -> expr ? expr .)
    ]               reduce using rule 51 (binary_operation -> expr ? expr .)
    ,               reduce using rule 51 (binary_operation -> expr ? expr .)
    ELSE            reduce using rule 51 (binary_operation -> expr ? expr .)
    RIGHT_ASSIGN    shift and go to state 34
    [               shift and go to state 35
    LBB             shift and go to state 36
    +               shift and go to state 37
    -               shift and go to state 38
    *               shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 41
    INT_DIV         shift and go to state 42
    /               shift and go to state 43
    :               shift and go to state 44
    ~               shift and go to state 45
    LT              shift and go to state 47
    LE              shift and go to state 48
    EQ              shift and go to state 49
    NE              shift and go to state 50
    GE              shift and go to state 51
    GT              shift and go to state 52
    AND             shift and go to state 53
    OR              shift and go to state 54
    AND2            shift and go to state 55
    OR2             shift and go to state 56
    MATRIX_MULT     shift and go to state 57
    $               shift and go to state 58
    @               shift and go to state 59

  ! RIGHT_ASSIGN    [ reduce using rule 51 (binary_operation -> expr ? expr .) ]
  ! [               [ reduce using rule 51 (binary_operation -> expr ? expr .) ]
  ! LBB             [ reduce using rule 51 (binary_operation -> expr ? expr .) ]
  ! +               [ reduce using rule 51 (binary_operation -> expr ? expr .) ]
  ! -               [ reduce using rule 51 (binary_operation -> expr ? expr .) ]
  ! *               [ reduce using rule 51 (binary_operation -> expr ? expr .) ]
  ! POWER           [ reduce using rule 51 (binary_operation -> expr ? expr .) ]
  ! MOD             [ reduce using rule 51 (binary_operation -> expr ? expr .) ]
  ! INT_DIV         [ reduce using rule 51 (binary_operation -> expr ? expr .) ]
  ! /               [ reduce using rule 51 (binary_operation -> expr ? expr .) ]
  ! :               [ reduce using rule 51 (binary_operation -> expr ? expr .) ]
  ! ~               [ reduce using rule 51 (binary_operation -> expr ? expr .) ]
  ! LT              [ reduce using rule 51 (binary_operation -> expr ? expr .) ]
  ! LE              [ reduce using rule 51 (binary_operation -> expr ? expr .) ]
  ! EQ              [ reduce using rule 51 (binary_operation -> expr ? expr .) ]
  ! NE              [ reduce using rule 51 (binary_operation -> expr ? expr .) ]
  ! GE              [ reduce using rule 51 (binary_operation -> expr ? expr .) ]
  ! GT              [ reduce using rule 51 (binary_operation -> expr ? expr .) ]
  ! AND             [ reduce using rule 51 (binary_operation -> expr ? expr .) ]
  ! OR              [ reduce using rule 51 (binary_operation -> expr ? expr .) ]
  ! AND2            [ reduce using rule 51 (binary_operation -> expr ? expr .) ]
  ! OR2             [ reduce using rule 51 (binary_operation -> expr ? expr .) ]
  ! MATRIX_MULT     [ reduce using rule 51 (binary_operation -> expr ? expr .) ]
  ! $               [ reduce using rule 51 (binary_operation -> expr ? expr .) ]
  ! @               [ reduce using rule 51 (binary_operation -> expr ? expr .) ]
  ! ?               [ shift and go to state 46 ]


state 94

    (52) binary_operation -> expr LT expr .
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    RIGHT_ASSIGN    reduce using rule 52 (binary_operation -> expr LT expr .)
    ~               reduce using rule 52 (binary_operation -> expr LT expr .)
    ?               reduce using rule 52 (binary_operation -> expr LT expr .)
    LT              reduce using rule 52 (binary_operation -> expr LT expr .)
    LE              reduce using rule 52 (binary_operation -> expr LT expr .)
    EQ              reduce using rule 52 (binary_operation -> expr LT expr .)
    NE              reduce using rule 52 (binary_operation -> expr LT expr .)
    GE              reduce using rule 52 (binary_operation -> expr LT expr .)
    GT              reduce using rule 52 (binary_operation -> expr LT expr .)
    AND             reduce using rule 52 (binary_operation -> expr LT expr .)
    OR              reduce using rule 52 (binary_operation -> expr LT expr .)
    AND2            reduce using rule 52 (binary_operation -> expr LT expr .)
    OR2             reduce using rule 52 (binary_operation -> expr LT expr .)
    ;               reduce using rule 52 (binary_operation -> expr LT expr .)
    NLINE           reduce using rule 52 (binary_operation -> expr LT expr .)
    $end            reduce using rule 52 (binary_operation -> expr LT expr .)
    )               reduce using rule 52 (binary_operation -> expr LT expr .)
    }               reduce using rule 52 (binary_operation -> expr LT expr .)
    ]               reduce using rule 52 (binary_operation -> expr LT expr .)
    ,               reduce using rule 52 (binary_operation -> expr LT expr .)
    ELSE            reduce using rule 52 (binary_operation -> expr LT expr .)
    [               shift and go to state 35
    LBB             shift and go to state 36
    +               shift and go to state 37
    -               shift and go to state 38
    *               shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 41
    INT_DIV         shift and go to state 42
    /               shift and go to state 43
    :               shift and go to state 44
    MATRIX_MULT     shift and go to state 57
    $               shift and go to state 58
    @               shift and go to state 59

  ! [               [ reduce using rule 52 (binary_operation -> expr LT expr .) ]
  ! LBB             [ reduce using rule 52 (binary_operation -> expr LT expr .) ]
  ! +               [ reduce using rule 52 (binary_operation -> expr LT expr .) ]
  ! -               [ reduce using rule 52 (binary_operation -> expr LT expr .) ]
  ! *               [ reduce using rule 52 (binary_operation -> expr LT expr .) ]
  ! POWER           [ reduce using rule 52 (binary_operation -> expr LT expr .) ]
  ! MOD             [ reduce using rule 52 (binary_operation -> expr LT expr .) ]
  ! INT_DIV         [ reduce using rule 52 (binary_operation -> expr LT expr .) ]
  ! /               [ reduce using rule 52 (binary_operation -> expr LT expr .) ]
  ! :               [ reduce using rule 52 (binary_operation -> expr LT expr .) ]
  ! MATRIX_MULT     [ reduce using rule 52 (binary_operation -> expr LT expr .) ]
  ! $               [ reduce using rule 52 (binary_operation -> expr LT expr .) ]
  ! @               [ reduce using rule 52 (binary_operation -> expr LT expr .) ]
  ! RIGHT_ASSIGN    [ shift and go to state 34 ]
  ! ~               [ shift and go to state 45 ]
  ! ?               [ shift and go to state 46 ]
  ! LT              [ shift and go to state 47 ]
  ! LE              [ shift and go to state 48 ]
  ! EQ              [ shift and go to state 49 ]
  ! NE              [ shift and go to state 50 ]
  ! GE              [ shift and go to state 51 ]
  ! GT              [ shift and go to state 52 ]
  ! AND             [ shift and go to state 53 ]
  ! OR              [ shift and go to state 54 ]
  ! AND2            [ shift and go to state 55 ]
  ! OR2             [ shift and go to state 56 ]


state 95

    (53) binary_operation -> expr LE expr .
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    RIGHT_ASSIGN    reduce using rule 53 (binary_operation -> expr LE expr .)
    ~               reduce using rule 53 (binary_operation -> expr LE expr .)
    ?               reduce using rule 53 (binary_operation -> expr LE expr .)
    LT              reduce using rule 53 (binary_operation -> expr LE expr .)
    LE              reduce using rule 53 (binary_operation -> expr LE expr .)
    EQ              reduce using rule 53 (binary_operation -> expr LE expr .)
    NE              reduce using rule 53 (binary_operation -> expr LE expr .)
    GE              reduce using rule 53 (binary_operation -> expr LE expr .)
    GT              reduce using rule 53 (binary_operation -> expr LE expr .)
    AND             reduce using rule 53 (binary_operation -> expr LE expr .)
    OR              reduce using rule 53 (binary_operation -> expr LE expr .)
    AND2            reduce using rule 53 (binary_operation -> expr LE expr .)
    OR2             reduce using rule 53 (binary_operation -> expr LE expr .)
    ;               reduce using rule 53 (binary_operation -> expr LE expr .)
    NLINE           reduce using rule 53 (binary_operation -> expr LE expr .)
    $end            reduce using rule 53 (binary_operation -> expr LE expr .)
    )               reduce using rule 53 (binary_operation -> expr LE expr .)
    }               reduce using rule 53 (binary_operation -> expr LE expr .)
    ]               reduce using rule 53 (binary_operation -> expr LE expr .)
    ,               reduce using rule 53 (binary_operation -> expr LE expr .)
    ELSE            reduce using rule 53 (binary_operation -> expr LE expr .)
    [               shift and go to state 35
    LBB             shift and go to state 36
    +               shift and go to state 37
    -               shift and go to state 38
    *               shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 41
    INT_DIV         shift and go to state 42
    /               shift and go to state 43
    :               shift and go to state 44
    MATRIX_MULT     shift and go to state 57
    $               shift and go to state 58
    @               shift and go to state 59

  ! [               [ reduce using rule 53 (binary_operation -> expr LE expr .) ]
  ! LBB             [ reduce using rule 53 (binary_operation -> expr LE expr .) ]
  ! +               [ reduce using rule 53 (binary_operation -> expr LE expr .) ]
  ! -               [ reduce using rule 53 (binary_operation -> expr LE expr .) ]
  ! *               [ reduce using rule 53 (binary_operation -> expr LE expr .) ]
  ! POWER           [ reduce using rule 53 (binary_operation -> expr LE expr .) ]
  ! MOD             [ reduce using rule 53 (binary_operation -> expr LE expr .) ]
  ! INT_DIV         [ reduce using rule 53 (binary_operation -> expr LE expr .) ]
  ! /               [ reduce using rule 53 (binary_operation -> expr LE expr .) ]
  ! :               [ reduce using rule 53 (binary_operation -> expr LE expr .) ]
  ! MATRIX_MULT     [ reduce using rule 53 (binary_operation -> expr LE expr .) ]
  ! $               [ reduce using rule 53 (binary_operation -> expr LE expr .) ]
  ! @               [ reduce using rule 53 (binary_operation -> expr LE expr .) ]
  ! RIGHT_ASSIGN    [ shift and go to state 34 ]
  ! ~               [ shift and go to state 45 ]
  ! ?               [ shift and go to state 46 ]
  ! LT              [ shift and go to state 47 ]
  ! LE              [ shift and go to state 48 ]
  ! EQ              [ shift and go to state 49 ]
  ! NE              [ shift and go to state 50 ]
  ! GE              [ shift and go to state 51 ]
  ! GT              [ shift and go to state 52 ]
  ! AND             [ shift and go to state 53 ]
  ! OR              [ shift and go to state 54 ]
  ! AND2            [ shift and go to state 55 ]
  ! OR2             [ shift and go to state 56 ]


state 96

    (54) binary_operation -> expr EQ expr .
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    RIGHT_ASSIGN    reduce using rule 54 (binary_operation -> expr EQ expr .)
    ~               reduce using rule 54 (binary_operation -> expr EQ expr .)
    ?               reduce using rule 54 (binary_operation -> expr EQ expr .)
    LT              reduce using rule 54 (binary_operation -> expr EQ expr .)
    LE              reduce using rule 54 (binary_operation -> expr EQ expr .)
    EQ              reduce using rule 54 (binary_operation -> expr EQ expr .)
    NE              reduce using rule 54 (binary_operation -> expr EQ expr .)
    GE              reduce using rule 54 (binary_operation -> expr EQ expr .)
    GT              reduce using rule 54 (binary_operation -> expr EQ expr .)
    AND             reduce using rule 54 (binary_operation -> expr EQ expr .)
    OR              reduce using rule 54 (binary_operation -> expr EQ expr .)
    AND2            reduce using rule 54 (binary_operation -> expr EQ expr .)
    OR2             reduce using rule 54 (binary_operation -> expr EQ expr .)
    ;               reduce using rule 54 (binary_operation -> expr EQ expr .)
    NLINE           reduce using rule 54 (binary_operation -> expr EQ expr .)
    $end            reduce using rule 54 (binary_operation -> expr EQ expr .)
    )               reduce using rule 54 (binary_operation -> expr EQ expr .)
    }               reduce using rule 54 (binary_operation -> expr EQ expr .)
    ]               reduce using rule 54 (binary_operation -> expr EQ expr .)
    ,               reduce using rule 54 (binary_operation -> expr EQ expr .)
    ELSE            reduce using rule 54 (binary_operation -> expr EQ expr .)
    [               shift and go to state 35
    LBB             shift and go to state 36
    +               shift and go to state 37
    -               shift and go to state 38
    *               shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 41
    INT_DIV         shift and go to state 42
    /               shift and go to state 43
    :               shift and go to state 44
    MATRIX_MULT     shift and go to state 57
    $               shift and go to state 58
    @               shift and go to state 59

  ! [               [ reduce using rule 54 (binary_operation -> expr EQ expr .) ]
  ! LBB             [ reduce using rule 54 (binary_operation -> expr EQ expr .) ]
  ! +               [ reduce using rule 54 (binary_operation -> expr EQ expr .) ]
  ! -               [ reduce using rule 54 (binary_operation -> expr EQ expr .) ]
  ! *               [ reduce using rule 54 (binary_operation -> expr EQ expr .) ]
  ! POWER           [ reduce using rule 54 (binary_operation -> expr EQ expr .) ]
  ! MOD             [ reduce using rule 54 (binary_operation -> expr EQ expr .) ]
  ! INT_DIV         [ reduce using rule 54 (binary_operation -> expr EQ expr .) ]
  ! /               [ reduce using rule 54 (binary_operation -> expr EQ expr .) ]
  ! :               [ reduce using rule 54 (binary_operation -> expr EQ expr .) ]
  ! MATRIX_MULT     [ reduce using rule 54 (binary_operation -> expr EQ expr .) ]
  ! $               [ reduce using rule 54 (binary_operation -> expr EQ expr .) ]
  ! @               [ reduce using rule 54 (binary_operation -> expr EQ expr .) ]
  ! RIGHT_ASSIGN    [ shift and go to state 34 ]
  ! ~               [ shift and go to state 45 ]
  ! ?               [ shift and go to state 46 ]
  ! LT              [ shift and go to state 47 ]
  ! LE              [ shift and go to state 48 ]
  ! EQ              [ shift and go to state 49 ]
  ! NE              [ shift and go to state 50 ]
  ! GE              [ shift and go to state 51 ]
  ! GT              [ shift and go to state 52 ]
  ! AND             [ shift and go to state 53 ]
  ! OR              [ shift and go to state 54 ]
  ! AND2            [ shift and go to state 55 ]
  ! OR2             [ shift and go to state 56 ]


state 97

    (55) binary_operation -> expr NE expr .
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    RIGHT_ASSIGN    reduce using rule 55 (binary_operation -> expr NE expr .)
    ~               reduce using rule 55 (binary_operation -> expr NE expr .)
    ?               reduce using rule 55 (binary_operation -> expr NE expr .)
    LT              reduce using rule 55 (binary_operation -> expr NE expr .)
    LE              reduce using rule 55 (binary_operation -> expr NE expr .)
    EQ              reduce using rule 55 (binary_operation -> expr NE expr .)
    NE              reduce using rule 55 (binary_operation -> expr NE expr .)
    GE              reduce using rule 55 (binary_operation -> expr NE expr .)
    GT              reduce using rule 55 (binary_operation -> expr NE expr .)
    AND             reduce using rule 55 (binary_operation -> expr NE expr .)
    OR              reduce using rule 55 (binary_operation -> expr NE expr .)
    AND2            reduce using rule 55 (binary_operation -> expr NE expr .)
    OR2             reduce using rule 55 (binary_operation -> expr NE expr .)
    ;               reduce using rule 55 (binary_operation -> expr NE expr .)
    NLINE           reduce using rule 55 (binary_operation -> expr NE expr .)
    $end            reduce using rule 55 (binary_operation -> expr NE expr .)
    )               reduce using rule 55 (binary_operation -> expr NE expr .)
    }               reduce using rule 55 (binary_operation -> expr NE expr .)
    ]               reduce using rule 55 (binary_operation -> expr NE expr .)
    ,               reduce using rule 55 (binary_operation -> expr NE expr .)
    ELSE            reduce using rule 55 (binary_operation -> expr NE expr .)
    [               shift and go to state 35
    LBB             shift and go to state 36
    +               shift and go to state 37
    -               shift and go to state 38
    *               shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 41
    INT_DIV         shift and go to state 42
    /               shift and go to state 43
    :               shift and go to state 44
    MATRIX_MULT     shift and go to state 57
    $               shift and go to state 58
    @               shift and go to state 59

  ! [               [ reduce using rule 55 (binary_operation -> expr NE expr .) ]
  ! LBB             [ reduce using rule 55 (binary_operation -> expr NE expr .) ]
  ! +               [ reduce using rule 55 (binary_operation -> expr NE expr .) ]
  ! -               [ reduce using rule 55 (binary_operation -> expr NE expr .) ]
  ! *               [ reduce using rule 55 (binary_operation -> expr NE expr .) ]
  ! POWER           [ reduce using rule 55 (binary_operation -> expr NE expr .) ]
  ! MOD             [ reduce using rule 55 (binary_operation -> expr NE expr .) ]
  ! INT_DIV         [ reduce using rule 55 (binary_operation -> expr NE expr .) ]
  ! /               [ reduce using rule 55 (binary_operation -> expr NE expr .) ]
  ! :               [ reduce using rule 55 (binary_operation -> expr NE expr .) ]
  ! MATRIX_MULT     [ reduce using rule 55 (binary_operation -> expr NE expr .) ]
  ! $               [ reduce using rule 55 (binary_operation -> expr NE expr .) ]
  ! @               [ reduce using rule 55 (binary_operation -> expr NE expr .) ]
  ! RIGHT_ASSIGN    [ shift and go to state 34 ]
  ! ~               [ shift and go to state 45 ]
  ! ?               [ shift and go to state 46 ]
  ! LT              [ shift and go to state 47 ]
  ! LE              [ shift and go to state 48 ]
  ! EQ              [ shift and go to state 49 ]
  ! NE              [ shift and go to state 50 ]
  ! GE              [ shift and go to state 51 ]
  ! GT              [ shift and go to state 52 ]
  ! AND             [ shift and go to state 53 ]
  ! OR              [ shift and go to state 54 ]
  ! AND2            [ shift and go to state 55 ]
  ! OR2             [ shift and go to state 56 ]


state 98

    (56) binary_operation -> expr GE expr .
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    RIGHT_ASSIGN    reduce using rule 56 (binary_operation -> expr GE expr .)
    ~               reduce using rule 56 (binary_operation -> expr GE expr .)
    ?               reduce using rule 56 (binary_operation -> expr GE expr .)
    LT              reduce using rule 56 (binary_operation -> expr GE expr .)
    LE              reduce using rule 56 (binary_operation -> expr GE expr .)
    EQ              reduce using rule 56 (binary_operation -> expr GE expr .)
    NE              reduce using rule 56 (binary_operation -> expr GE expr .)
    GE              reduce using rule 56 (binary_operation -> expr GE expr .)
    GT              reduce using rule 56 (binary_operation -> expr GE expr .)
    AND             reduce using rule 56 (binary_operation -> expr GE expr .)
    OR              reduce using rule 56 (binary_operation -> expr GE expr .)
    AND2            reduce using rule 56 (binary_operation -> expr GE expr .)
    OR2             reduce using rule 56 (binary_operation -> expr GE expr .)
    ;               reduce using rule 56 (binary_operation -> expr GE expr .)
    NLINE           reduce using rule 56 (binary_operation -> expr GE expr .)
    $end            reduce using rule 56 (binary_operation -> expr GE expr .)
    )               reduce using rule 56 (binary_operation -> expr GE expr .)
    }               reduce using rule 56 (binary_operation -> expr GE expr .)
    ]               reduce using rule 56 (binary_operation -> expr GE expr .)
    ,               reduce using rule 56 (binary_operation -> expr GE expr .)
    ELSE            reduce using rule 56 (binary_operation -> expr GE expr .)
    [               shift and go to state 35
    LBB             shift and go to state 36
    +               shift and go to state 37
    -               shift and go to state 38
    *               shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 41
    INT_DIV         shift and go to state 42
    /               shift and go to state 43
    :               shift and go to state 44
    MATRIX_MULT     shift and go to state 57
    $               shift and go to state 58
    @               shift and go to state 59

  ! [               [ reduce using rule 56 (binary_operation -> expr GE expr .) ]
  ! LBB             [ reduce using rule 56 (binary_operation -> expr GE expr .) ]
  ! +               [ reduce using rule 56 (binary_operation -> expr GE expr .) ]
  ! -               [ reduce using rule 56 (binary_operation -> expr GE expr .) ]
  ! *               [ reduce using rule 56 (binary_operation -> expr GE expr .) ]
  ! POWER           [ reduce using rule 56 (binary_operation -> expr GE expr .) ]
  ! MOD             [ reduce using rule 56 (binary_operation -> expr GE expr .) ]
  ! INT_DIV         [ reduce using rule 56 (binary_operation -> expr GE expr .) ]
  ! /               [ reduce using rule 56 (binary_operation -> expr GE expr .) ]
  ! :               [ reduce using rule 56 (binary_operation -> expr GE expr .) ]
  ! MATRIX_MULT     [ reduce using rule 56 (binary_operation -> expr GE expr .) ]
  ! $               [ reduce using rule 56 (binary_operation -> expr GE expr .) ]
  ! @               [ reduce using rule 56 (binary_operation -> expr GE expr .) ]
  ! RIGHT_ASSIGN    [ shift and go to state 34 ]
  ! ~               [ shift and go to state 45 ]
  ! ?               [ shift and go to state 46 ]
  ! LT              [ shift and go to state 47 ]
  ! LE              [ shift and go to state 48 ]
  ! EQ              [ shift and go to state 49 ]
  ! NE              [ shift and go to state 50 ]
  ! GE              [ shift and go to state 51 ]
  ! GT              [ shift and go to state 52 ]
  ! AND             [ shift and go to state 53 ]
  ! OR              [ shift and go to state 54 ]
  ! AND2            [ shift and go to state 55 ]
  ! OR2             [ shift and go to state 56 ]


state 99

    (57) binary_operation -> expr GT expr .
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    RIGHT_ASSIGN    reduce using rule 57 (binary_operation -> expr GT expr .)
    ~               reduce using rule 57 (binary_operation -> expr GT expr .)
    ?               reduce using rule 57 (binary_operation -> expr GT expr .)
    LT              reduce using rule 57 (binary_operation -> expr GT expr .)
    LE              reduce using rule 57 (binary_operation -> expr GT expr .)
    EQ              reduce using rule 57 (binary_operation -> expr GT expr .)
    NE              reduce using rule 57 (binary_operation -> expr GT expr .)
    GE              reduce using rule 57 (binary_operation -> expr GT expr .)
    GT              reduce using rule 57 (binary_operation -> expr GT expr .)
    AND             reduce using rule 57 (binary_operation -> expr GT expr .)
    OR              reduce using rule 57 (binary_operation -> expr GT expr .)
    AND2            reduce using rule 57 (binary_operation -> expr GT expr .)
    OR2             reduce using rule 57 (binary_operation -> expr GT expr .)
    ;               reduce using rule 57 (binary_operation -> expr GT expr .)
    NLINE           reduce using rule 57 (binary_operation -> expr GT expr .)
    $end            reduce using rule 57 (binary_operation -> expr GT expr .)
    )               reduce using rule 57 (binary_operation -> expr GT expr .)
    }               reduce using rule 57 (binary_operation -> expr GT expr .)
    ]               reduce using rule 57 (binary_operation -> expr GT expr .)
    ,               reduce using rule 57 (binary_operation -> expr GT expr .)
    ELSE            reduce using rule 57 (binary_operation -> expr GT expr .)
    [               shift and go to state 35
    LBB             shift and go to state 36
    +               shift and go to state 37
    -               shift and go to state 38
    *               shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 41
    INT_DIV         shift and go to state 42
    /               shift and go to state 43
    :               shift and go to state 44
    MATRIX_MULT     shift and go to state 57
    $               shift and go to state 58
    @               shift and go to state 59

  ! [               [ reduce using rule 57 (binary_operation -> expr GT expr .) ]
  ! LBB             [ reduce using rule 57 (binary_operation -> expr GT expr .) ]
  ! +               [ reduce using rule 57 (binary_operation -> expr GT expr .) ]
  ! -               [ reduce using rule 57 (binary_operation -> expr GT expr .) ]
  ! *               [ reduce using rule 57 (binary_operation -> expr GT expr .) ]
  ! POWER           [ reduce using rule 57 (binary_operation -> expr GT expr .) ]
  ! MOD             [ reduce using rule 57 (binary_operation -> expr GT expr .) ]
  ! INT_DIV         [ reduce using rule 57 (binary_operation -> expr GT expr .) ]
  ! /               [ reduce using rule 57 (binary_operation -> expr GT expr .) ]
  ! :               [ reduce using rule 57 (binary_operation -> expr GT expr .) ]
  ! MATRIX_MULT     [ reduce using rule 57 (binary_operation -> expr GT expr .) ]
  ! $               [ reduce using rule 57 (binary_operation -> expr GT expr .) ]
  ! @               [ reduce using rule 57 (binary_operation -> expr GT expr .) ]
  ! RIGHT_ASSIGN    [ shift and go to state 34 ]
  ! ~               [ shift and go to state 45 ]
  ! ?               [ shift and go to state 46 ]
  ! LT              [ shift and go to state 47 ]
  ! LE              [ shift and go to state 48 ]
  ! EQ              [ shift and go to state 49 ]
  ! NE              [ shift and go to state 50 ]
  ! GE              [ shift and go to state 51 ]
  ! GT              [ shift and go to state 52 ]
  ! AND             [ shift and go to state 53 ]
  ! OR              [ shift and go to state 54 ]
  ! AND2            [ shift and go to state 55 ]
  ! OR2             [ shift and go to state 56 ]


state 100

    (58) binary_operation -> expr AND expr .
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    RIGHT_ASSIGN    reduce using rule 58 (binary_operation -> expr AND expr .)
    ~               reduce using rule 58 (binary_operation -> expr AND expr .)
    ?               reduce using rule 58 (binary_operation -> expr AND expr .)
    AND             reduce using rule 58 (binary_operation -> expr AND expr .)
    OR              reduce using rule 58 (binary_operation -> expr AND expr .)
    AND2            reduce using rule 58 (binary_operation -> expr AND expr .)
    OR2             reduce using rule 58 (binary_operation -> expr AND expr .)
    ;               reduce using rule 58 (binary_operation -> expr AND expr .)
    NLINE           reduce using rule 58 (binary_operation -> expr AND expr .)
    $end            reduce using rule 58 (binary_operation -> expr AND expr .)
    )               reduce using rule 58 (binary_operation -> expr AND expr .)
    }               reduce using rule 58 (binary_operation -> expr AND expr .)
    ]               reduce using rule 58 (binary_operation -> expr AND expr .)
    ,               reduce using rule 58 (binary_operation -> expr AND expr .)
    ELSE            reduce using rule 58 (binary_operation -> expr AND expr .)
    [               shift and go to state 35
    LBB             shift and go to state 36
    +               shift and go to state 37
    -               shift and go to state 38
    *               shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 41
    INT_DIV         shift and go to state 42
    /               shift and go to state 43
    :               shift and go to state 44
    LT              shift and go to state 47
    LE              shift and go to state 48
    EQ              shift and go to state 49
    NE              shift and go to state 50
    GE              shift and go to state 51
    GT              shift and go to state 52
    MATRIX_MULT     shift and go to state 57
    $               shift and go to state 58
    @               shift and go to state 59

  ! [               [ reduce using rule 58 (binary_operation -> expr AND expr .) ]
  ! LBB             [ reduce using rule 58 (binary_operation -> expr AND expr .) ]
  ! +               [ reduce using rule 58 (binary_operation -> expr AND expr .) ]
  ! -               [ reduce using rule 58 (binary_operation -> expr AND expr .) ]
  ! *               [ reduce using rule 58 (binary_operation -> expr AND expr .) ]
  ! POWER           [ reduce using rule 58 (binary_operation -> expr AND expr .) ]
  ! MOD             [ reduce using rule 58 (binary_operation -> expr AND expr .) ]
  ! INT_DIV         [ reduce using rule 58 (binary_operation -> expr AND expr .) ]
  ! /               [ reduce using rule 58 (binary_operation -> expr AND expr .) ]
  ! :               [ reduce using rule 58 (binary_operation -> expr AND expr .) ]
  ! LT              [ reduce using rule 58 (binary_operation -> expr AND expr .) ]
  ! LE              [ reduce using rule 58 (binary_operation -> expr AND expr .) ]
  ! EQ              [ reduce using rule 58 (binary_operation -> expr AND expr .) ]
  ! NE              [ reduce using rule 58 (binary_operation -> expr AND expr .) ]
  ! GE              [ reduce using rule 58 (binary_operation -> expr AND expr .) ]
  ! GT              [ reduce using rule 58 (binary_operation -> expr AND expr .) ]
  ! MATRIX_MULT     [ reduce using rule 58 (binary_operation -> expr AND expr .) ]
  ! $               [ reduce using rule 58 (binary_operation -> expr AND expr .) ]
  ! @               [ reduce using rule 58 (binary_operation -> expr AND expr .) ]
  ! RIGHT_ASSIGN    [ shift and go to state 34 ]
  ! ~               [ shift and go to state 45 ]
  ! ?               [ shift and go to state 46 ]
  ! AND             [ shift and go to state 53 ]
  ! OR              [ shift and go to state 54 ]
  ! AND2            [ shift and go to state 55 ]
  ! OR2             [ shift and go to state 56 ]


state 101

    (59) binary_operation -> expr OR expr .
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    RIGHT_ASSIGN    reduce using rule 59 (binary_operation -> expr OR expr .)
    ~               reduce using rule 59 (binary_operation -> expr OR expr .)
    ?               reduce using rule 59 (binary_operation -> expr OR expr .)
    OR              reduce using rule 59 (binary_operation -> expr OR expr .)
    OR2             reduce using rule 59 (binary_operation -> expr OR expr .)
    ;               reduce using rule 59 (binary_operation -> expr OR expr .)
    NLINE           reduce using rule 59 (binary_operation -> expr OR expr .)
    $end            reduce using rule 59 (binary_operation -> expr OR expr .)
    )               reduce using rule 59 (binary_operation -> expr OR expr .)
    }               reduce using rule 59 (binary_operation -> expr OR expr .)
    ]               reduce using rule 59 (binary_operation -> expr OR expr .)
    ,               reduce using rule 59 (binary_operation -> expr OR expr .)
    ELSE            reduce using rule 59 (binary_operation -> expr OR expr .)
    [               shift and go to state 35
    LBB             shift and go to state 36
    +               shift and go to state 37
    -               shift and go to state 38
    *               shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 41
    INT_DIV         shift and go to state 42
    /               shift and go to state 43
    :               shift and go to state 44
    LT              shift and go to state 47
    LE              shift and go to state 48
    EQ              shift and go to state 49
    NE              shift and go to state 50
    GE              shift and go to state 51
    GT              shift and go to state 52
    AND             shift and go to state 53
    AND2            shift and go to state 55
    MATRIX_MULT     shift and go to state 57
    $               shift and go to state 58
    @               shift and go to state 59

  ! [               [ reduce using rule 59 (binary_operation -> expr OR expr .) ]
  ! LBB             [ reduce using rule 59 (binary_operation -> expr OR expr .) ]
  ! +               [ reduce using rule 59 (binary_operation -> expr OR expr .) ]
  ! -               [ reduce using rule 59 (binary_operation -> expr OR expr .) ]
  ! *               [ reduce using rule 59 (binary_operation -> expr OR expr .) ]
  ! POWER           [ reduce using rule 59 (binary_operation -> expr OR expr .) ]
  ! MOD             [ reduce using rule 59 (binary_operation -> expr OR expr .) ]
  ! INT_DIV         [ reduce using rule 59 (binary_operation -> expr OR expr .) ]
  ! /               [ reduce using rule 59 (binary_operation -> expr OR expr .) ]
  ! :               [ reduce using rule 59 (binary_operation -> expr OR expr .) ]
  ! LT              [ reduce using rule 59 (binary_operation -> expr OR expr .) ]
  ! LE              [ reduce using rule 59 (binary_operation -> expr OR expr .) ]
  ! EQ              [ reduce using rule 59 (binary_operation -> expr OR expr .) ]
  ! NE              [ reduce using rule 59 (binary_operation -> expr OR expr .) ]
  ! GE              [ reduce using rule 59 (binary_operation -> expr OR expr .) ]
  ! GT              [ reduce using rule 59 (binary_operation -> expr OR expr .) ]
  ! AND             [ reduce using rule 59 (binary_operation -> expr OR expr .) ]
  ! AND2            [ reduce using rule 59 (binary_operation -> expr OR expr .) ]
  ! MATRIX_MULT     [ reduce using rule 59 (binary_operation -> expr OR expr .) ]
  ! $               [ reduce using rule 59 (binary_operation -> expr OR expr .) ]
  ! @               [ reduce using rule 59 (binary_operation -> expr OR expr .) ]
  ! RIGHT_ASSIGN    [ shift and go to state 34 ]
  ! ~               [ shift and go to state 45 ]
  ! ?               [ shift and go to state 46 ]
  ! OR              [ shift and go to state 54 ]
  ! OR2             [ shift and go to state 56 ]


state 102

    (60) binary_operation -> expr AND2 expr .
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    RIGHT_ASSIGN    reduce using rule 60 (binary_operation -> expr AND2 expr .)
    ~               reduce using rule 60 (binary_operation -> expr AND2 expr .)
    ?               reduce using rule 60 (binary_operation -> expr AND2 expr .)
    AND             reduce using rule 60 (binary_operation -> expr AND2 expr .)
    OR              reduce using rule 60 (binary_operation -> expr AND2 expr .)
    AND2            reduce using rule 60 (binary_operation -> expr AND2 expr .)
    OR2             reduce using rule 60 (binary_operation -> expr AND2 expr .)
    ;               reduce using rule 60 (binary_operation -> expr AND2 expr .)
    NLINE           reduce using rule 60 (binary_operation -> expr AND2 expr .)
    $end            reduce using rule 60 (binary_operation -> expr AND2 expr .)
    )               reduce using rule 60 (binary_operation -> expr AND2 expr .)
    }               reduce using rule 60 (binary_operation -> expr AND2 expr .)
    ]               reduce using rule 60 (binary_operation -> expr AND2 expr .)
    ,               reduce using rule 60 (binary_operation -> expr AND2 expr .)
    ELSE            reduce using rule 60 (binary_operation -> expr AND2 expr .)
    [               shift and go to state 35
    LBB             shift and go to state 36
    +               shift and go to state 37
    -               shift and go to state 38
    *               shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 41
    INT_DIV         shift and go to state 42
    /               shift and go to state 43
    :               shift and go to state 44
    LT              shift and go to state 47
    LE              shift and go to state 48
    EQ              shift and go to state 49
    NE              shift and go to state 50
    GE              shift and go to state 51
    GT              shift and go to state 52
    MATRIX_MULT     shift and go to state 57
    $               shift and go to state 58
    @               shift and go to state 59

  ! [               [ reduce using rule 60 (binary_operation -> expr AND2 expr .) ]
  ! LBB             [ reduce using rule 60 (binary_operation -> expr AND2 expr .) ]
  ! +               [ reduce using rule 60 (binary_operation -> expr AND2 expr .) ]
  ! -               [ reduce using rule 60 (binary_operation -> expr AND2 expr .) ]
  ! *               [ reduce using rule 60 (binary_operation -> expr AND2 expr .) ]
  ! POWER           [ reduce using rule 60 (binary_operation -> expr AND2 expr .) ]
  ! MOD             [ reduce using rule 60 (binary_operation -> expr AND2 expr .) ]
  ! INT_DIV         [ reduce using rule 60 (binary_operation -> expr AND2 expr .) ]
  ! /               [ reduce using rule 60 (binary_operation -> expr AND2 expr .) ]
  ! :               [ reduce using rule 60 (binary_operation -> expr AND2 expr .) ]
  ! LT              [ reduce using rule 60 (binary_operation -> expr AND2 expr .) ]
  ! LE              [ reduce using rule 60 (binary_operation -> expr AND2 expr .) ]
  ! EQ              [ reduce using rule 60 (binary_operation -> expr AND2 expr .) ]
  ! NE              [ reduce using rule 60 (binary_operation -> expr AND2 expr .) ]
  ! GE              [ reduce using rule 60 (binary_operation -> expr AND2 expr .) ]
  ! GT              [ reduce using rule 60 (binary_operation -> expr AND2 expr .) ]
  ! MATRIX_MULT     [ reduce using rule 60 (binary_operation -> expr AND2 expr .) ]
  ! $               [ reduce using rule 60 (binary_operation -> expr AND2 expr .) ]
  ! @               [ reduce using rule 60 (binary_operation -> expr AND2 expr .) ]
  ! RIGHT_ASSIGN    [ shift and go to state 34 ]
  ! ~               [ shift and go to state 45 ]
  ! ?               [ shift and go to state 46 ]
  ! AND             [ shift and go to state 53 ]
  ! OR              [ shift and go to state 54 ]
  ! AND2            [ shift and go to state 55 ]
  ! OR2             [ shift and go to state 56 ]


state 103

    (61) binary_operation -> expr OR2 expr .
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    RIGHT_ASSIGN    reduce using rule 61 (binary_operation -> expr OR2 expr .)
    ~               reduce using rule 61 (binary_operation -> expr OR2 expr .)
    ?               reduce using rule 61 (binary_operation -> expr OR2 expr .)
    OR              reduce using rule 61 (binary_operation -> expr OR2 expr .)
    OR2             reduce using rule 61 (binary_operation -> expr OR2 expr .)
    ;               reduce using rule 61 (binary_operation -> expr OR2 expr .)
    NLINE           reduce using rule 61 (binary_operation -> expr OR2 expr .)
    $end            reduce using rule 61 (binary_operation -> expr OR2 expr .)
    )               reduce using rule 61 (binary_operation -> expr OR2 expr .)
    }               reduce using rule 61 (binary_operation -> expr OR2 expr .)
    ]               reduce using rule 61 (binary_operation -> expr OR2 expr .)
    ,               reduce using rule 61 (binary_operation -> expr OR2 expr .)
    ELSE            reduce using rule 61 (binary_operation -> expr OR2 expr .)
    [               shift and go to state 35
    LBB             shift and go to state 36
    +               shift and go to state 37
    -               shift and go to state 38
    *               shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 41
    INT_DIV         shift and go to state 42
    /               shift and go to state 43
    :               shift and go to state 44
    LT              shift and go to state 47
    LE              shift and go to state 48
    EQ              shift and go to state 49
    NE              shift and go to state 50
    GE              shift and go to state 51
    GT              shift and go to state 52
    AND             shift and go to state 53
    AND2            shift and go to state 55
    MATRIX_MULT     shift and go to state 57
    $               shift and go to state 58
    @               shift and go to state 59

  ! [               [ reduce using rule 61 (binary_operation -> expr OR2 expr .) ]
  ! LBB             [ reduce using rule 61 (binary_operation -> expr OR2 expr .) ]
  ! +               [ reduce using rule 61 (binary_operation -> expr OR2 expr .) ]
  ! -               [ reduce using rule 61 (binary_operation -> expr OR2 expr .) ]
  ! *               [ reduce using rule 61 (binary_operation -> expr OR2 expr .) ]
  ! POWER           [ reduce using rule 61 (binary_operation -> expr OR2 expr .) ]
  ! MOD             [ reduce using rule 61 (binary_operation -> expr OR2 expr .) ]
  ! INT_DIV         [ reduce using rule 61 (binary_operation -> expr OR2 expr .) ]
  ! /               [ reduce using rule 61 (binary_operation -> expr OR2 expr .) ]
  ! :               [ reduce using rule 61 (binary_operation -> expr OR2 expr .) ]
  ! LT              [ reduce using rule 61 (binary_operation -> expr OR2 expr .) ]
  ! LE              [ reduce using rule 61 (binary_operation -> expr OR2 expr .) ]
  ! EQ              [ reduce using rule 61 (binary_operation -> expr OR2 expr .) ]
  ! NE              [ reduce using rule 61 (binary_operation -> expr OR2 expr .) ]
  ! GE              [ reduce using rule 61 (binary_operation -> expr OR2 expr .) ]
  ! GT              [ reduce using rule 61 (binary_operation -> expr OR2 expr .) ]
  ! AND             [ reduce using rule 61 (binary_operation -> expr OR2 expr .) ]
  ! AND2            [ reduce using rule 61 (binary_operation -> expr OR2 expr .) ]
  ! MATRIX_MULT     [ reduce using rule 61 (binary_operation -> expr OR2 expr .) ]
  ! $               [ reduce using rule 61 (binary_operation -> expr OR2 expr .) ]
  ! @               [ reduce using rule 61 (binary_operation -> expr OR2 expr .) ]
  ! RIGHT_ASSIGN    [ shift and go to state 34 ]
  ! ~               [ shift and go to state 45 ]
  ! ?               [ shift and go to state 46 ]
  ! OR              [ shift and go to state 54 ]
  ! OR2             [ shift and go to state 56 ]


state 104

    (62) binary_operation -> expr MATRIX_MULT expr .
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    RIGHT_ASSIGN    reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .)
    +               reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .)
    -               reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .)
    *               reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .)
    MOD             reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .)
    INT_DIV         reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .)
    /               reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .)
    ~               reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .)
    ?               reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .)
    LT              reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .)
    LE              reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .)
    EQ              reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .)
    NE              reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .)
    GE              reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .)
    GT              reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .)
    AND             reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .)
    OR              reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .)
    AND2            reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .)
    OR2             reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .)
    MATRIX_MULT     reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .)
    ;               reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .)
    NLINE           reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .)
    $end            reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .)
    )               reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .)
    }               reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .)
    ]               reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .)
    ,               reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .)
    ELSE            reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .)
    [               shift and go to state 35
    LBB             shift and go to state 36
    POWER           shift and go to state 40
    :               shift and go to state 44
    $               shift and go to state 58
    @               shift and go to state 59

  ! [               [ reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .) ]
  ! LBB             [ reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .) ]
  ! POWER           [ reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .) ]
  ! :               [ reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .) ]
  ! $               [ reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .) ]
  ! @               [ reduce using rule 62 (binary_operation -> expr MATRIX_MULT expr .) ]
  ! RIGHT_ASSIGN    [ shift and go to state 34 ]
  ! +               [ shift and go to state 37 ]
  ! -               [ shift and go to state 38 ]
  ! *               [ shift and go to state 39 ]
  ! MOD             [ shift and go to state 41 ]
  ! INT_DIV         [ shift and go to state 42 ]
  ! /               [ shift and go to state 43 ]
  ! ~               [ shift and go to state 45 ]
  ! ?               [ shift and go to state 46 ]
  ! LT              [ shift and go to state 47 ]
  ! LE              [ shift and go to state 48 ]
  ! EQ              [ shift and go to state 49 ]
  ! NE              [ shift and go to state 50 ]
  ! GE              [ shift and go to state 51 ]
  ! GT              [ shift and go to state 52 ]
  ! AND             [ shift and go to state 53 ]
  ! OR              [ shift and go to state 54 ]
  ! AND2            [ shift and go to state 55 ]
  ! OR2             [ shift and go to state 56 ]
  ! MATRIX_MULT     [ shift and go to state 57 ]


state 105

    (63) binary_operation -> expr $ SYMBOL .

    RIGHT_ASSIGN    reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    [               reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    LBB             reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    +               reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    -               reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    *               reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    POWER           reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    MOD             reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    INT_DIV         reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    /               reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    :               reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    ~               reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    ?               reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    LT              reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    LE              reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    EQ              reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    NE              reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    GE              reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    GT              reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    AND             reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    OR              reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    AND2            reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    OR2             reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    MATRIX_MULT     reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    $               reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    @               reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    ;               reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    NLINE           reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    $end            reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    )               reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    }               reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    ]               reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    ,               reduce using rule 63 (binary_operation -> expr $ SYMBOL .)
    ELSE            reduce using rule 63 (binary_operation -> expr $ SYMBOL .)


state 106

    (64) binary_operation -> expr $ STR_CONST .

    RIGHT_ASSIGN    reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    [               reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    LBB             reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    +               reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    -               reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    *               reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    POWER           reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    MOD             reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    INT_DIV         reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    /               reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    :               reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    ~               reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    ?               reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    LT              reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    LE              reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    EQ              reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    NE              reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    GE              reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    GT              reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    AND             reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    OR              reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    AND2            reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    OR2             reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    MATRIX_MULT     reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    $               reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    @               reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    ;               reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    NLINE           reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    $end            reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    )               reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    }               reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    ]               reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    ,               reduce using rule 64 (binary_operation -> expr $ STR_CONST .)
    ELSE            reduce using rule 64 (binary_operation -> expr $ STR_CONST .)


state 107

    (65) binary_operation -> expr @ SYMBOL .

    RIGHT_ASSIGN    reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    [               reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    LBB             reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    +               reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    -               reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    *               reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    POWER           reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    MOD             reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    INT_DIV         reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    /               reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    :               reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    ~               reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    ?               reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    LT              reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    LE              reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    EQ              reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    NE              reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    GE              reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    GT              reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    AND             reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    OR              reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    AND2            reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    OR2             reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    MATRIX_MULT     reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    $               reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    @               reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    ;               reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    NLINE           reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    $end            reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    )               reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    }               reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    ]               reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    ,               reduce using rule 65 (binary_operation -> expr @ SYMBOL .)
    ELSE            reduce using rule 65 (binary_operation -> expr @ SYMBOL .)


state 108

    (66) binary_operation -> expr @ STR_CONST .

    RIGHT_ASSIGN    reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    [               reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    LBB             reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    +               reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    -               reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    *               reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    POWER           reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    MOD             reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    INT_DIV         reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    /               reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    :               reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    ~               reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    ?               reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    LT              reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    LE              reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    EQ              reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    NE              reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    GE              reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    GT              reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    AND             reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    OR              reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    AND2            reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    OR2             reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    MATRIX_MULT     reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    $               reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    @               reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    ;               reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    NLINE           reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    $end            reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    )               reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    }               reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    ]               reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    ,               reduce using rule 66 (binary_operation -> expr @ STR_CONST .)
    ELSE            reduce using rule 66 (binary_operation -> expr @ STR_CONST .)


state 109

    (11) expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .

    ;               reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    NLINE           reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    $end            reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    )               reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    }               reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    RIGHT_ASSIGN    reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    [               reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    LBB             reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    +               reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    -               reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    *               reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    POWER           reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    MOD             reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    INT_DIV         reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    /               reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    :               reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    ~               reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    ?               reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    LT              reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    LE              reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    EQ              reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    NE              reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    GE              reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    GT              reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    AND             reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    OR              reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    AND2            reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    OR2             reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    MATRIX_MULT     reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    $               reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    @               reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    ]               reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    ,               reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)
    ELSE            reduce using rule 11 (expr_or_assign -> SYMBOL EQ_ASSIGN expr_or_assign .)


state 110

    (19) expr -> SYMBOL LEFT_ASSIGN expr .
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    ?               reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .)
    ;               reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .)
    NLINE           reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .)
    $end            reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .)
    )               reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .)
    }               reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .)
    ]               reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .)
    ,               reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .)
    ELSE            reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .)
    RIGHT_ASSIGN    shift and go to state 34
    [               shift and go to state 35
    LBB             shift and go to state 36
    +               shift and go to state 37
    -               shift and go to state 38
    *               shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 41
    INT_DIV         shift and go to state 42
    /               shift and go to state 43
    :               shift and go to state 44
    ~               shift and go to state 45
    LT              shift and go to state 47
    LE              shift and go to state 48
    EQ              shift and go to state 49
    NE              shift and go to state 50
    GE              shift and go to state 51
    GT              shift and go to state 52
    AND             shift and go to state 53
    OR              shift and go to state 54
    AND2            shift and go to state 55
    OR2             shift and go to state 56
    MATRIX_MULT     shift and go to state 57
    $               shift and go to state 58
    @               shift and go to state 59

  ! RIGHT_ASSIGN    [ reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .) ]
  ! [               [ reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .) ]
  ! LBB             [ reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .) ]
  ! +               [ reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .) ]
  ! -               [ reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .) ]
  ! *               [ reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .) ]
  ! POWER           [ reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .) ]
  ! MOD             [ reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .) ]
  ! INT_DIV         [ reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .) ]
  ! /               [ reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .) ]
  ! :               [ reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .) ]
  ! ~               [ reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .) ]
  ! LT              [ reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .) ]
  ! LE              [ reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .) ]
  ! EQ              [ reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .) ]
  ! NE              [ reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .) ]
  ! GE              [ reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .) ]
  ! GT              [ reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .) ]
  ! AND             [ reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .) ]
  ! OR              [ reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .) ]
  ! AND2            [ reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .) ]
  ! OR2             [ reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .) ]
  ! MATRIX_MULT     [ reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .) ]
  ! $               [ reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .) ]
  ! @               [ reduce using rule 19 (expr -> SYMBOL LEFT_ASSIGN expr .) ]
  ! ?               [ shift and go to state 46 ]


state 111

    (25) expr -> SYMBOL ( sublist . )
    (32) sublist -> sublist . , sub

    )               shift and go to state 123
    ,               shift and go to state 121


state 112

    (20) expr -> ( expr_or_assign ) .

    RIGHT_ASSIGN    reduce using rule 20 (expr -> ( expr_or_assign ) .)
    [               reduce using rule 20 (expr -> ( expr_or_assign ) .)
    LBB             reduce using rule 20 (expr -> ( expr_or_assign ) .)
    +               reduce using rule 20 (expr -> ( expr_or_assign ) .)
    -               reduce using rule 20 (expr -> ( expr_or_assign ) .)
    *               reduce using rule 20 (expr -> ( expr_or_assign ) .)
    POWER           reduce using rule 20 (expr -> ( expr_or_assign ) .)
    MOD             reduce using rule 20 (expr -> ( expr_or_assign ) .)
    INT_DIV         reduce using rule 20 (expr -> ( expr_or_assign ) .)
    /               reduce using rule 20 (expr -> ( expr_or_assign ) .)
    :               reduce using rule 20 (expr -> ( expr_or_assign ) .)
    ~               reduce using rule 20 (expr -> ( expr_or_assign ) .)
    ?               reduce using rule 20 (expr -> ( expr_or_assign ) .)
    LT              reduce using rule 20 (expr -> ( expr_or_assign ) .)
    LE              reduce using rule 20 (expr -> ( expr_or_assign ) .)
    EQ              reduce using rule 20 (expr -> ( expr_or_assign ) .)
    NE              reduce using rule 20 (expr -> ( expr_or_assign ) .)
    GE              reduce using rule 20 (expr -> ( expr_or_assign ) .)
    GT              reduce using rule 20 (expr -> ( expr_or_assign ) .)
    AND             reduce using rule 20 (expr -> ( expr_or_assign ) .)
    OR              reduce using rule 20 (expr -> ( expr_or_assign ) .)
    AND2            reduce using rule 20 (expr -> ( expr_or_assign ) .)
    OR2             reduce using rule 20 (expr -> ( expr_or_assign ) .)
    MATRIX_MULT     reduce using rule 20 (expr -> ( expr_or_assign ) .)
    $               reduce using rule 20 (expr -> ( expr_or_assign ) .)
    @               reduce using rule 20 (expr -> ( expr_or_assign ) .)
    ;               reduce using rule 20 (expr -> ( expr_or_assign ) .)
    NLINE           reduce using rule 20 (expr -> ( expr_or_assign ) .)
    $end            reduce using rule 20 (expr -> ( expr_or_assign ) .)
    )               reduce using rule 20 (expr -> ( expr_or_assign ) .)
    }               reduce using rule 20 (expr -> ( expr_or_assign ) .)
    ]               reduce using rule 20 (expr -> ( expr_or_assign ) .)
    ,               reduce using rule 20 (expr -> ( expr_or_assign ) .)
    ELSE            reduce using rule 20 (expr -> ( expr_or_assign ) .)


state 113

    (23) expr -> { exprlist } .

    RIGHT_ASSIGN    reduce using rule 23 (expr -> { exprlist } .)
    [               reduce using rule 23 (expr -> { exprlist } .)
    LBB             reduce using rule 23 (expr -> { exprlist } .)
    +               reduce using rule 23 (expr -> { exprlist } .)
    -               reduce using rule 23 (expr -> { exprlist } .)
    *               reduce using rule 23 (expr -> { exprlist } .)
    POWER           reduce using rule 23 (expr -> { exprlist } .)
    MOD             reduce using rule 23 (expr -> { exprlist } .)
    INT_DIV         reduce using rule 23 (expr -> { exprlist } .)
    /               reduce using rule 23 (expr -> { exprlist } .)
    :               reduce using rule 23 (expr -> { exprlist } .)
    ~               reduce using rule 23 (expr -> { exprlist } .)
    ?               reduce using rule 23 (expr -> { exprlist } .)
    LT              reduce using rule 23 (expr -> { exprlist } .)
    LE              reduce using rule 23 (expr -> { exprlist } .)
    EQ              reduce using rule 23 (expr -> { exprlist } .)
    NE              reduce using rule 23 (expr -> { exprlist } .)
    GE              reduce using rule 23 (expr -> { exprlist } .)
    GT              reduce using rule 23 (expr -> { exprlist } .)
    AND             reduce using rule 23 (expr -> { exprlist } .)
    OR              reduce using rule 23 (expr -> { exprlist } .)
    AND2            reduce using rule 23 (expr -> { exprlist } .)
    OR2             reduce using rule 23 (expr -> { exprlist } .)
    MATRIX_MULT     reduce using rule 23 (expr -> { exprlist } .)
    $               reduce using rule 23 (expr -> { exprlist } .)
    @               reduce using rule 23 (expr -> { exprlist } .)
    ;               reduce using rule 23 (expr -> { exprlist } .)
    NLINE           reduce using rule 23 (expr -> { exprlist } .)
    $end            reduce using rule 23 (expr -> { exprlist } .)
    )               reduce using rule 23 (expr -> { exprlist } .)
    }               reduce using rule 23 (expr -> { exprlist } .)
    ]               reduce using rule 23 (expr -> { exprlist } .)
    ,               reduce using rule 23 (expr -> { exprlist } .)
    ELSE            reduce using rule 23 (expr -> { exprlist } .)


state 114

    (24) expr -> FUNCTION ( formlist . ) expr_or_assign_nl
    (28) formlist -> formlist . , SYMBOL
    (29) formlist -> formlist . , SYMBOL EQ_ASSIGN expr

    )               shift and go to state 124
    ,               shift and go to state 125


state 115

    (26) formlist -> SYMBOL .
    (27) formlist -> SYMBOL . EQ_ASSIGN expr

    )               reduce using rule 26 (formlist -> SYMBOL .)
    ,               reduce using rule 26 (formlist -> SYMBOL .)
    EQ_ASSIGN       shift and go to state 126


state 116

    (30) formlist -> empty .

    )               reduce using rule 30 (formlist -> empty .)
    ,               reduce using rule 30 (formlist -> empty .)


state 117

    (75) if_statement -> IF ( expr . ) expr_or_assign_nl else_statement
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    )               shift and go to state 127
    RIGHT_ASSIGN    shift and go to state 34
    [               shift and go to state 35
    LBB             shift and go to state 36
    +               shift and go to state 37
    -               shift and go to state 38
    *               shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 41
    INT_DIV         shift and go to state 42
    /               shift and go to state 43
    :               shift and go to state 44
    ~               shift and go to state 45
    ?               shift and go to state 46
    LT              shift and go to state 47
    LE              shift and go to state 48
    EQ              shift and go to state 49
    NE              shift and go to state 50
    GE              shift and go to state 51
    GT              shift and go to state 52
    AND             shift and go to state 53
    OR              shift and go to state 54
    AND2            shift and go to state 55
    OR2             shift and go to state 56
    MATRIX_MULT     shift and go to state 57
    $               shift and go to state 58
    @               shift and go to state 59


state 118

    (79) for_statement -> FOR ( SYMBOL . IN expr ) expr_or_assign_nl

    IN              shift and go to state 128


state 119

    (80) while_statement -> WHILE ( expr . ) expr_or_assign_nl
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    )               shift and go to state 129
    RIGHT_ASSIGN    shift and go to state 34
    [               shift and go to state 35
    LBB             shift and go to state 36
    +               shift and go to state 37
    -               shift and go to state 38
    *               shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 41
    INT_DIV         shift and go to state 42
    /               shift and go to state 43
    :               shift and go to state 44
    ~               shift and go to state 45
    ?               shift and go to state 46
    LT              shift and go to state 47
    LE              shift and go to state 48
    EQ              shift and go to state 49
    NE              shift and go to state 50
    GE              shift and go to state 51
    GT              shift and go to state 52
    AND             shift and go to state 53
    OR              shift and go to state 54
    AND2            shift and go to state 55
    OR2             shift and go to state 56
    MATRIX_MULT     shift and go to state 57
    $               shift and go to state 58
    @               shift and go to state 59


state 120

    (21) expr -> expr [ sublist ] .

    RIGHT_ASSIGN    reduce using rule 21 (expr -> expr [ sublist ] .)
    [               reduce using rule 21 (expr -> expr [ sublist ] .)
    LBB             reduce using rule 21 (expr -> expr [ sublist ] .)
    +               reduce using rule 21 (expr -> expr [ sublist ] .)
    -               reduce using rule 21 (expr -> expr [ sublist ] .)
    *               reduce using rule 21 (expr -> expr [ sublist ] .)
    POWER           reduce using rule 21 (expr -> expr [ sublist ] .)
    MOD             reduce using rule 21 (expr -> expr [ sublist ] .)
    INT_DIV         reduce using rule 21 (expr -> expr [ sublist ] .)
    /               reduce using rule 21 (expr -> expr [ sublist ] .)
    :               reduce using rule 21 (expr -> expr [ sublist ] .)
    ~               reduce using rule 21 (expr -> expr [ sublist ] .)
    ?               reduce using rule 21 (expr -> expr [ sublist ] .)
    LT              reduce using rule 21 (expr -> expr [ sublist ] .)
    LE              reduce using rule 21 (expr -> expr [ sublist ] .)
    EQ              reduce using rule 21 (expr -> expr [ sublist ] .)
    NE              reduce using rule 21 (expr -> expr [ sublist ] .)
    GE              reduce using rule 21 (expr -> expr [ sublist ] .)
    GT              reduce using rule 21 (expr -> expr [ sublist ] .)
    AND             reduce using rule 21 (expr -> expr [ sublist ] .)
    OR              reduce using rule 21 (expr -> expr [ sublist ] .)
    AND2            reduce using rule 21 (expr -> expr [ sublist ] .)
    OR2             reduce using rule 21 (expr -> expr [ sublist ] .)
    MATRIX_MULT     reduce using rule 21 (expr -> expr [ sublist ] .)
    $               reduce using rule 21 (expr -> expr [ sublist ] .)
    @               reduce using rule 21 (expr -> expr [ sublist ] .)
    ;               reduce using rule 21 (expr -> expr [ sublist ] .)
    NLINE           reduce using rule 21 (expr -> expr [ sublist ] .)
    $end            reduce using rule 21 (expr -> expr [ sublist ] .)
    )               reduce using rule 21 (expr -> expr [ sublist ] .)
    }               reduce using rule 21 (expr -> expr [ sublist ] .)
    ]               reduce using rule 21 (expr -> expr [ sublist ] .)
    ,               reduce using rule 21 (expr -> expr [ sublist ] .)
    ELSE            reduce using rule 21 (expr -> expr [ sublist ] .)


state 121

    (32) sublist -> sublist , . sub
    (33) sub -> . empty
    (34) sub -> . expr
    (81) empty -> .
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    ]               reduce using rule 81 (empty -> .)
    ,               reduce using rule 81 (empty -> .)
    )               reduce using rule 81 (empty -> .)
    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    sub                            shift and go to state 130
    empty                          shift and go to state 82
    expr                           shift and go to state 79
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 122

    (22) expr -> expr LBB sublist ] . ]

    ]               shift and go to state 131


state 123

    (25) expr -> SYMBOL ( sublist ) .

    RIGHT_ASSIGN    reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    [               reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    LBB             reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    +               reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    -               reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    *               reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    POWER           reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    MOD             reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    INT_DIV         reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    /               reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    :               reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    ~               reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    ?               reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    LT              reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    LE              reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    EQ              reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    NE              reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    GE              reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    GT              reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    AND             reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    OR              reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    AND2            reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    OR2             reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    MATRIX_MULT     reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    $               reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    @               reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    ;               reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    NLINE           reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    $end            reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    )               reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    }               reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    ]               reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    ,               reduce using rule 25 (expr -> SYMBOL ( sublist ) .)
    ELSE            reduce using rule 25 (expr -> SYMBOL ( sublist ) .)


state 124

    (24) expr -> FUNCTION ( formlist ) . expr_or_assign_nl
    (12) expr_or_assign_nl -> . expr_or_assign
    (13) expr_or_assign_nl -> . emptyline expr_or_assign
    (10) expr_or_assign -> . expr
    (11) expr_or_assign -> . SYMBOL EQ_ASSIGN expr_or_assign
    (2) emptyline -> . NLINE
    (3) emptyline -> . emptyline NLINE
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 6
    NLINE           shift and go to state 33
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr_or_assign_nl              shift and go to state 132
    expr_or_assign                 shift and go to state 133
    emptyline                      shift and go to state 134
    expr                           shift and go to state 5
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 125

    (28) formlist -> formlist , . SYMBOL
    (29) formlist -> formlist , . SYMBOL EQ_ASSIGN expr

    SYMBOL          shift and go to state 135


state 126

    (27) formlist -> SYMBOL EQ_ASSIGN . expr
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 136
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 127

    (75) if_statement -> IF ( expr ) . expr_or_assign_nl else_statement
    (12) expr_or_assign_nl -> . expr_or_assign
    (13) expr_or_assign_nl -> . emptyline expr_or_assign
    (10) expr_or_assign -> . expr
    (11) expr_or_assign -> . SYMBOL EQ_ASSIGN expr_or_assign
    (2) emptyline -> . NLINE
    (3) emptyline -> . emptyline NLINE
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 6
    NLINE           shift and go to state 33
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 5
    expr_or_assign_nl              shift and go to state 137
    expr_or_assign                 shift and go to state 133
    emptyline                      shift and go to state 134
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 128

    (79) for_statement -> FOR ( SYMBOL IN . expr ) expr_or_assign_nl
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 138
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 129

    (80) while_statement -> WHILE ( expr ) . expr_or_assign_nl
    (12) expr_or_assign_nl -> . expr_or_assign
    (13) expr_or_assign_nl -> . emptyline expr_or_assign
    (10) expr_or_assign -> . expr
    (11) expr_or_assign -> . SYMBOL EQ_ASSIGN expr_or_assign
    (2) emptyline -> . NLINE
    (3) emptyline -> . emptyline NLINE
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 6
    NLINE           shift and go to state 33
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 5
    expr_or_assign_nl              shift and go to state 139
    expr_or_assign                 shift and go to state 133
    emptyline                      shift and go to state 134
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 130

    (32) sublist -> sublist , sub .

    ]               reduce using rule 32 (sublist -> sublist , sub .)
    ,               reduce using rule 32 (sublist -> sublist , sub .)
    )               reduce using rule 32 (sublist -> sublist , sub .)


state 131

    (22) expr -> expr LBB sublist ] ] .

    RIGHT_ASSIGN    reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    [               reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    LBB             reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    +               reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    -               reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    *               reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    POWER           reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    MOD             reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    INT_DIV         reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    /               reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    :               reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    ~               reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    ?               reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    LT              reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    LE              reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    EQ              reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    NE              reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    GE              reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    GT              reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    AND             reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    OR              reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    AND2            reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    OR2             reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    MATRIX_MULT     reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    $               reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    @               reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    ;               reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    NLINE           reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    $end            reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    )               reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    }               reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    ]               reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    ,               reduce using rule 22 (expr -> expr LBB sublist ] ] .)
    ELSE            reduce using rule 22 (expr -> expr LBB sublist ] ] .)


state 132

    (24) expr -> FUNCTION ( formlist ) expr_or_assign_nl .

    RIGHT_ASSIGN    reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    [               reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    LBB             reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    +               reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    -               reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    *               reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    POWER           reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    MOD             reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    INT_DIV         reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    /               reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    :               reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    ~               reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    ?               reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    LT              reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    LE              reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    EQ              reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    NE              reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    GE              reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    GT              reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    AND             reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    OR              reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    AND2            reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    OR2             reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    MATRIX_MULT     reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    $               reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    @               reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    ;               reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    NLINE           reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    $end            reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    )               reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    }               reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    ]               reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    ,               reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)
    ELSE            reduce using rule 24 (expr -> FUNCTION ( formlist ) expr_or_assign_nl .)


state 133

    (12) expr_or_assign_nl -> expr_or_assign .

    RIGHT_ASSIGN    reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    [               reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    LBB             reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    +               reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    -               reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    *               reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    POWER           reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    MOD             reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    INT_DIV         reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    /               reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    :               reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    ~               reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    ?               reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    LT              reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    LE              reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    EQ              reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    NE              reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    GE              reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    GT              reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    AND             reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    OR              reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    AND2            reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    OR2             reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    MATRIX_MULT     reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    $               reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    @               reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    ;               reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    NLINE           reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    $end            reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    )               reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    }               reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    ]               reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    ,               reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)
    ELSE            reduce using rule 12 (expr_or_assign_nl -> expr_or_assign .)


state 134

    (13) expr_or_assign_nl -> emptyline . expr_or_assign
    (3) emptyline -> emptyline . NLINE
    (10) expr_or_assign -> . expr
    (11) expr_or_assign -> . SYMBOL EQ_ASSIGN expr_or_assign
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    NLINE           shift and go to state 77
    SYMBOL          shift and go to state 6
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr_or_assign                 shift and go to state 140
    expr                           shift and go to state 5
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 135

    (28) formlist -> formlist , SYMBOL .
    (29) formlist -> formlist , SYMBOL . EQ_ASSIGN expr

    )               reduce using rule 28 (formlist -> formlist , SYMBOL .)
    ,               reduce using rule 28 (formlist -> formlist , SYMBOL .)
    EQ_ASSIGN       shift and go to state 141


state 136

    (27) formlist -> SYMBOL EQ_ASSIGN expr .
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    )               reduce using rule 27 (formlist -> SYMBOL EQ_ASSIGN expr .)
    ,               reduce using rule 27 (formlist -> SYMBOL EQ_ASSIGN expr .)
    RIGHT_ASSIGN    shift and go to state 34
    [               shift and go to state 35
    LBB             shift and go to state 36
    +               shift and go to state 37
    -               shift and go to state 38
    *               shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 41
    INT_DIV         shift and go to state 42
    /               shift and go to state 43
    :               shift and go to state 44
    ~               shift and go to state 45
    ?               shift and go to state 46
    LT              shift and go to state 47
    LE              shift and go to state 48
    EQ              shift and go to state 49
    NE              shift and go to state 50
    GE              shift and go to state 51
    GT              shift and go to state 52
    AND             shift and go to state 53
    OR              shift and go to state 54
    AND2            shift and go to state 55
    OR2             shift and go to state 56
    MATRIX_MULT     shift and go to state 57
    $               shift and go to state 58
    @               shift and go to state 59


state 137

    (75) if_statement -> IF ( expr ) expr_or_assign_nl . else_statement
    (76) else_statement -> . empty
    (77) else_statement -> . ELSE expr_or_assign_nl
    (78) else_statement -> . NLINE else_statement
    (81) empty -> .

  ! shift/reduce conflict for NLINE resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 144
    NLINE           shift and go to state 145
    RIGHT_ASSIGN    reduce using rule 81 (empty -> .)
    [               reduce using rule 81 (empty -> .)
    LBB             reduce using rule 81 (empty -> .)
    +               reduce using rule 81 (empty -> .)
    -               reduce using rule 81 (empty -> .)
    *               reduce using rule 81 (empty -> .)
    POWER           reduce using rule 81 (empty -> .)
    MOD             reduce using rule 81 (empty -> .)
    INT_DIV         reduce using rule 81 (empty -> .)
    /               reduce using rule 81 (empty -> .)
    :               reduce using rule 81 (empty -> .)
    ~               reduce using rule 81 (empty -> .)
    ?               reduce using rule 81 (empty -> .)
    LT              reduce using rule 81 (empty -> .)
    LE              reduce using rule 81 (empty -> .)
    EQ              reduce using rule 81 (empty -> .)
    NE              reduce using rule 81 (empty -> .)
    GE              reduce using rule 81 (empty -> .)
    GT              reduce using rule 81 (empty -> .)
    AND             reduce using rule 81 (empty -> .)
    OR              reduce using rule 81 (empty -> .)
    AND2            reduce using rule 81 (empty -> .)
    OR2             reduce using rule 81 (empty -> .)
    MATRIX_MULT     reduce using rule 81 (empty -> .)
    $               reduce using rule 81 (empty -> .)
    @               reduce using rule 81 (empty -> .)
    ;               reduce using rule 81 (empty -> .)
    $end            reduce using rule 81 (empty -> .)
    )               reduce using rule 81 (empty -> .)
    }               reduce using rule 81 (empty -> .)
    ]               reduce using rule 81 (empty -> .)
    ,               reduce using rule 81 (empty -> .)

  ! NLINE           [ reduce using rule 81 (empty -> .) ]
  ! ELSE            [ reduce using rule 81 (empty -> .) ]

    else_statement                 shift and go to state 142
    empty                          shift and go to state 143

state 138

    (79) for_statement -> FOR ( SYMBOL IN expr . ) expr_or_assign_nl
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    )               shift and go to state 146
    RIGHT_ASSIGN    shift and go to state 34
    [               shift and go to state 35
    LBB             shift and go to state 36
    +               shift and go to state 37
    -               shift and go to state 38
    *               shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 41
    INT_DIV         shift and go to state 42
    /               shift and go to state 43
    :               shift and go to state 44
    ~               shift and go to state 45
    ?               shift and go to state 46
    LT              shift and go to state 47
    LE              shift and go to state 48
    EQ              shift and go to state 49
    NE              shift and go to state 50
    GE              shift and go to state 51
    GT              shift and go to state 52
    AND             shift and go to state 53
    OR              shift and go to state 54
    AND2            shift and go to state 55
    OR2             shift and go to state 56
    MATRIX_MULT     shift and go to state 57
    $               shift and go to state 58
    @               shift and go to state 59


state 139

    (80) while_statement -> WHILE ( expr ) expr_or_assign_nl .

    RIGHT_ASSIGN    reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    [               reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    LBB             reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    +               reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    -               reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    *               reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    POWER           reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    MOD             reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    INT_DIV         reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    /               reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    :               reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    ~               reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    ?               reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    LT              reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    LE              reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    EQ              reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    NE              reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    GE              reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    GT              reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    AND             reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    OR              reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    AND2            reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    OR2             reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    MATRIX_MULT     reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    $               reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    @               reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    ;               reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    NLINE           reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    $end            reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    )               reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    }               reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    ]               reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    ,               reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)
    ELSE            reduce using rule 80 (while_statement -> WHILE ( expr ) expr_or_assign_nl .)


state 140

    (13) expr_or_assign_nl -> emptyline expr_or_assign .

    RIGHT_ASSIGN    reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    [               reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    LBB             reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    +               reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    -               reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    *               reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    POWER           reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    MOD             reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    INT_DIV         reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    /               reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    :               reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    ~               reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    ?               reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    LT              reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    LE              reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    EQ              reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    NE              reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    GE              reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    GT              reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    AND             reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    OR              reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    AND2            reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    OR2             reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    MATRIX_MULT     reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    $               reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    @               reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    ;               reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    NLINE           reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    $end            reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    )               reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    }               reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    ]               reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    ,               reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)
    ELSE            reduce using rule 13 (expr_or_assign_nl -> emptyline expr_or_assign .)


state 141

    (29) formlist -> formlist , SYMBOL EQ_ASSIGN . expr
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 67
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 147
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 142

    (75) if_statement -> IF ( expr ) expr_or_assign_nl else_statement .

    RIGHT_ASSIGN    reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    [               reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    LBB             reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    +               reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    -               reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    *               reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    POWER           reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    MOD             reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    INT_DIV         reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    /               reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    :               reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    ~               reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    ?               reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    LT              reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    LE              reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    EQ              reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    NE              reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    GE              reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    GT              reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    AND             reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    OR              reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    AND2            reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    OR2             reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    MATRIX_MULT     reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    $               reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    @               reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    ;               reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    NLINE           reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    $end            reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    )               reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    }               reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    ]               reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    ,               reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)
    ELSE            reduce using rule 75 (if_statement -> IF ( expr ) expr_or_assign_nl else_statement .)


state 143

    (76) else_statement -> empty .

    RIGHT_ASSIGN    reduce using rule 76 (else_statement -> empty .)
    [               reduce using rule 76 (else_statement -> empty .)
    LBB             reduce using rule 76 (else_statement -> empty .)
    +               reduce using rule 76 (else_statement -> empty .)
    -               reduce using rule 76 (else_statement -> empty .)
    *               reduce using rule 76 (else_statement -> empty .)
    POWER           reduce using rule 76 (else_statement -> empty .)
    MOD             reduce using rule 76 (else_statement -> empty .)
    INT_DIV         reduce using rule 76 (else_statement -> empty .)
    /               reduce using rule 76 (else_statement -> empty .)
    :               reduce using rule 76 (else_statement -> empty .)
    ~               reduce using rule 76 (else_statement -> empty .)
    ?               reduce using rule 76 (else_statement -> empty .)
    LT              reduce using rule 76 (else_statement -> empty .)
    LE              reduce using rule 76 (else_statement -> empty .)
    EQ              reduce using rule 76 (else_statement -> empty .)
    NE              reduce using rule 76 (else_statement -> empty .)
    GE              reduce using rule 76 (else_statement -> empty .)
    GT              reduce using rule 76 (else_statement -> empty .)
    AND             reduce using rule 76 (else_statement -> empty .)
    OR              reduce using rule 76 (else_statement -> empty .)
    AND2            reduce using rule 76 (else_statement -> empty .)
    OR2             reduce using rule 76 (else_statement -> empty .)
    MATRIX_MULT     reduce using rule 76 (else_statement -> empty .)
    $               reduce using rule 76 (else_statement -> empty .)
    @               reduce using rule 76 (else_statement -> empty .)
    ;               reduce using rule 76 (else_statement -> empty .)
    NLINE           reduce using rule 76 (else_statement -> empty .)
    $end            reduce using rule 76 (else_statement -> empty .)
    )               reduce using rule 76 (else_statement -> empty .)
    }               reduce using rule 76 (else_statement -> empty .)
    ]               reduce using rule 76 (else_statement -> empty .)
    ,               reduce using rule 76 (else_statement -> empty .)
    ELSE            reduce using rule 76 (else_statement -> empty .)


state 144

    (77) else_statement -> ELSE . expr_or_assign_nl
    (12) expr_or_assign_nl -> . expr_or_assign
    (13) expr_or_assign_nl -> . emptyline expr_or_assign
    (10) expr_or_assign -> . expr
    (11) expr_or_assign -> . SYMBOL EQ_ASSIGN expr_or_assign
    (2) emptyline -> . NLINE
    (3) emptyline -> . emptyline NLINE
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 6
    NLINE           shift and go to state 33
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr_or_assign_nl              shift and go to state 148
    expr_or_assign                 shift and go to state 133
    emptyline                      shift and go to state 134
    expr                           shift and go to state 5
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 145

    (78) else_statement -> NLINE . else_statement
    (76) else_statement -> . empty
    (77) else_statement -> . ELSE expr_or_assign_nl
    (78) else_statement -> . NLINE else_statement
    (81) empty -> .

  ! shift/reduce conflict for NLINE resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 144
    NLINE           shift and go to state 145
    RIGHT_ASSIGN    reduce using rule 81 (empty -> .)
    [               reduce using rule 81 (empty -> .)
    LBB             reduce using rule 81 (empty -> .)
    +               reduce using rule 81 (empty -> .)
    -               reduce using rule 81 (empty -> .)
    *               reduce using rule 81 (empty -> .)
    POWER           reduce using rule 81 (empty -> .)
    MOD             reduce using rule 81 (empty -> .)
    INT_DIV         reduce using rule 81 (empty -> .)
    /               reduce using rule 81 (empty -> .)
    :               reduce using rule 81 (empty -> .)
    ~               reduce using rule 81 (empty -> .)
    ?               reduce using rule 81 (empty -> .)
    LT              reduce using rule 81 (empty -> .)
    LE              reduce using rule 81 (empty -> .)
    EQ              reduce using rule 81 (empty -> .)
    NE              reduce using rule 81 (empty -> .)
    GE              reduce using rule 81 (empty -> .)
    GT              reduce using rule 81 (empty -> .)
    AND             reduce using rule 81 (empty -> .)
    OR              reduce using rule 81 (empty -> .)
    AND2            reduce using rule 81 (empty -> .)
    OR2             reduce using rule 81 (empty -> .)
    MATRIX_MULT     reduce using rule 81 (empty -> .)
    $               reduce using rule 81 (empty -> .)
    @               reduce using rule 81 (empty -> .)
    ;               reduce using rule 81 (empty -> .)
    $end            reduce using rule 81 (empty -> .)
    )               reduce using rule 81 (empty -> .)
    }               reduce using rule 81 (empty -> .)
    ]               reduce using rule 81 (empty -> .)
    ,               reduce using rule 81 (empty -> .)

  ! NLINE           [ reduce using rule 81 (empty -> .) ]
  ! ELSE            [ reduce using rule 81 (empty -> .) ]

    else_statement                 shift and go to state 149
    empty                          shift and go to state 143

state 146

    (79) for_statement -> FOR ( SYMBOL IN expr ) . expr_or_assign_nl
    (12) expr_or_assign_nl -> . expr_or_assign
    (13) expr_or_assign_nl -> . emptyline expr_or_assign
    (10) expr_or_assign -> . expr
    (11) expr_or_assign -> . SYMBOL EQ_ASSIGN expr_or_assign
    (2) emptyline -> . NLINE
    (3) emptyline -> . emptyline NLINE
    (14) expr -> . const_or_symbol
    (15) expr -> . binary_operation
    (16) expr -> . unary_operation
    (17) expr -> . statement_declaration
    (18) expr -> . expr RIGHT_ASSIGN SYMBOL
    (19) expr -> . SYMBOL LEFT_ASSIGN expr
    (20) expr -> . ( expr_or_assign )
    (21) expr -> . expr [ sublist ]
    (22) expr -> . expr LBB sublist ] ]
    (23) expr -> . { exprlist }
    (24) expr -> . FUNCTION ( formlist ) expr_or_assign_nl
    (25) expr -> . SYMBOL ( sublist )
    (35) const_or_symbol -> . SYMBOL
    (36) const_or_symbol -> . STR_CONST
    (37) const_or_symbol -> . REAL
    (38) const_or_symbol -> . INT
    (39) const_or_symbol -> . NULL_CONST
    (40) const_or_symbol -> . TRUE
    (41) const_or_symbol -> . FALSE
    (42) binary_operation -> . expr + expr
    (43) binary_operation -> . expr - expr
    (44) binary_operation -> . expr * expr
    (45) binary_operation -> . expr POWER expr
    (46) binary_operation -> . expr MOD expr
    (47) binary_operation -> . expr INT_DIV expr
    (48) binary_operation -> . expr / expr
    (49) binary_operation -> . expr : expr
    (50) binary_operation -> . expr ~ expr
    (51) binary_operation -> . expr ? expr
    (52) binary_operation -> . expr LT expr
    (53) binary_operation -> . expr LE expr
    (54) binary_operation -> . expr EQ expr
    (55) binary_operation -> . expr NE expr
    (56) binary_operation -> . expr GE expr
    (57) binary_operation -> . expr GT expr
    (58) binary_operation -> . expr AND expr
    (59) binary_operation -> . expr OR expr
    (60) binary_operation -> . expr AND2 expr
    (61) binary_operation -> . expr OR2 expr
    (62) binary_operation -> . expr MATRIX_MULT expr
    (63) binary_operation -> . expr $ SYMBOL
    (64) binary_operation -> . expr $ STR_CONST
    (65) binary_operation -> . expr @ SYMBOL
    (66) binary_operation -> . expr @ STR_CONST
    (67) unary_operation -> . - expr
    (68) unary_operation -> . + expr
    (69) unary_operation -> . ! expr
    (70) unary_operation -> . ~ expr
    (71) unary_operation -> . ? expr
    (72) statement_declaration -> . if_statement
    (73) statement_declaration -> . for_statement
    (74) statement_declaration -> . while_statement
    (75) if_statement -> . IF ( expr ) expr_or_assign_nl else_statement
    (79) for_statement -> . FOR ( SYMBOL IN expr ) expr_or_assign_nl
    (80) while_statement -> . WHILE ( expr ) expr_or_assign_nl

    SYMBOL          shift and go to state 6
    NLINE           shift and go to state 33
    (               shift and go to state 11
    {               shift and go to state 12
    FUNCTION        shift and go to state 13
    STR_CONST       shift and go to state 14
    REAL            shift and go to state 15
    INT             shift and go to state 16
    NULL_CONST      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    -               shift and go to state 21
    +               shift and go to state 20
    !               shift and go to state 24
    ~               shift and go to state 22
    ?               shift and go to state 23
    IF              shift and go to state 28
    FOR             shift and go to state 29
    WHILE           shift and go to state 30

    expr                           shift and go to state 5
    expr_or_assign_nl              shift and go to state 150
    expr_or_assign                 shift and go to state 133
    emptyline                      shift and go to state 134
    const_or_symbol                shift and go to state 7
    binary_operation               shift and go to state 8
    unary_operation                shift and go to state 9
    statement_declaration          shift and go to state 10
    if_statement                   shift and go to state 25
    for_statement                  shift and go to state 26
    while_statement                shift and go to state 27

state 147

    (29) formlist -> formlist , SYMBOL EQ_ASSIGN expr .
    (18) expr -> expr . RIGHT_ASSIGN SYMBOL
    (21) expr -> expr . [ sublist ]
    (22) expr -> expr . LBB sublist ] ]
    (42) binary_operation -> expr . + expr
    (43) binary_operation -> expr . - expr
    (44) binary_operation -> expr . * expr
    (45) binary_operation -> expr . POWER expr
    (46) binary_operation -> expr . MOD expr
    (47) binary_operation -> expr . INT_DIV expr
    (48) binary_operation -> expr . / expr
    (49) binary_operation -> expr . : expr
    (50) binary_operation -> expr . ~ expr
    (51) binary_operation -> expr . ? expr
    (52) binary_operation -> expr . LT expr
    (53) binary_operation -> expr . LE expr
    (54) binary_operation -> expr . EQ expr
    (55) binary_operation -> expr . NE expr
    (56) binary_operation -> expr . GE expr
    (57) binary_operation -> expr . GT expr
    (58) binary_operation -> expr . AND expr
    (59) binary_operation -> expr . OR expr
    (60) binary_operation -> expr . AND2 expr
    (61) binary_operation -> expr . OR2 expr
    (62) binary_operation -> expr . MATRIX_MULT expr
    (63) binary_operation -> expr . $ SYMBOL
    (64) binary_operation -> expr . $ STR_CONST
    (65) binary_operation -> expr . @ SYMBOL
    (66) binary_operation -> expr . @ STR_CONST

    )               reduce using rule 29 (formlist -> formlist , SYMBOL EQ_ASSIGN expr .)
    ,               reduce using rule 29 (formlist -> formlist , SYMBOL EQ_ASSIGN expr .)
    RIGHT_ASSIGN    shift and go to state 34
    [               shift and go to state 35
    LBB             shift and go to state 36
    +               shift and go to state 37
    -               shift and go to state 38
    *               shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 41
    INT_DIV         shift and go to state 42
    /               shift and go to state 43
    :               shift and go to state 44
    ~               shift and go to state 45
    ?               shift and go to state 46
    LT              shift and go to state 47
    LE              shift and go to state 48
    EQ              shift and go to state 49
    NE              shift and go to state 50
    GE              shift and go to state 51
    GT              shift and go to state 52
    AND             shift and go to state 53
    OR              shift and go to state 54
    AND2            shift and go to state 55
    OR2             shift and go to state 56
    MATRIX_MULT     shift and go to state 57
    $               shift and go to state 58
    @               shift and go to state 59


state 148

    (77) else_statement -> ELSE expr_or_assign_nl .

    RIGHT_ASSIGN    reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    [               reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    LBB             reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    +               reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    -               reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    *               reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    POWER           reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    MOD             reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    INT_DIV         reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    /               reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    :               reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    ~               reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    ?               reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    LT              reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    LE              reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    EQ              reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    NE              reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    GE              reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    GT              reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    AND             reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    OR              reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    AND2            reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    OR2             reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    MATRIX_MULT     reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    $               reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    @               reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    ;               reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    NLINE           reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    $end            reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    )               reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    }               reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    ]               reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    ,               reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)
    ELSE            reduce using rule 77 (else_statement -> ELSE expr_or_assign_nl .)


state 149

    (78) else_statement -> NLINE else_statement .

    RIGHT_ASSIGN    reduce using rule 78 (else_statement -> NLINE else_statement .)
    [               reduce using rule 78 (else_statement -> NLINE else_statement .)
    LBB             reduce using rule 78 (else_statement -> NLINE else_statement .)
    +               reduce using rule 78 (else_statement -> NLINE else_statement .)
    -               reduce using rule 78 (else_statement -> NLINE else_statement .)
    *               reduce using rule 78 (else_statement -> NLINE else_statement .)
    POWER           reduce using rule 78 (else_statement -> NLINE else_statement .)
    MOD             reduce using rule 78 (else_statement -> NLINE else_statement .)
    INT_DIV         reduce using rule 78 (else_statement -> NLINE else_statement .)
    /               reduce using rule 78 (else_statement -> NLINE else_statement .)
    :               reduce using rule 78 (else_statement -> NLINE else_statement .)
    ~               reduce using rule 78 (else_statement -> NLINE else_statement .)
    ?               reduce using rule 78 (else_statement -> NLINE else_statement .)
    LT              reduce using rule 78 (else_statement -> NLINE else_statement .)
    LE              reduce using rule 78 (else_statement -> NLINE else_statement .)
    EQ              reduce using rule 78 (else_statement -> NLINE else_statement .)
    NE              reduce using rule 78 (else_statement -> NLINE else_statement .)
    GE              reduce using rule 78 (else_statement -> NLINE else_statement .)
    GT              reduce using rule 78 (else_statement -> NLINE else_statement .)
    AND             reduce using rule 78 (else_statement -> NLINE else_statement .)
    OR              reduce using rule 78 (else_statement -> NLINE else_statement .)
    AND2            reduce using rule 78 (else_statement -> NLINE else_statement .)
    OR2             reduce using rule 78 (else_statement -> NLINE else_statement .)
    MATRIX_MULT     reduce using rule 78 (else_statement -> NLINE else_statement .)
    $               reduce using rule 78 (else_statement -> NLINE else_statement .)
    @               reduce using rule 78 (else_statement -> NLINE else_statement .)
    ;               reduce using rule 78 (else_statement -> NLINE else_statement .)
    NLINE           reduce using rule 78 (else_statement -> NLINE else_statement .)
    $end            reduce using rule 78 (else_statement -> NLINE else_statement .)
    )               reduce using rule 78 (else_statement -> NLINE else_statement .)
    }               reduce using rule 78 (else_statement -> NLINE else_statement .)
    ]               reduce using rule 78 (else_statement -> NLINE else_statement .)
    ,               reduce using rule 78 (else_statement -> NLINE else_statement .)
    ELSE            reduce using rule 78 (else_statement -> NLINE else_statement .)


state 150

    (79) for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .

    RIGHT_ASSIGN    reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    [               reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    LBB             reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    +               reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    -               reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    *               reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    POWER           reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    MOD             reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    INT_DIV         reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    /               reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    :               reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    ~               reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    ?               reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    LT              reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    LE              reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    EQ              reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    NE              reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    GE              reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    GT              reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    AND             reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    OR              reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    AND2            reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    OR2             reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    MATRIX_MULT     reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    $               reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    @               reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    ;               reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    NLINE           reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    $end            reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    )               reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    }               reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    ]               reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    ,               reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)
    ELSE            reduce using rule 79 (for_statement -> FOR ( SYMBOL IN expr ) expr_or_assign_nl .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for RIGHT_ASSIGN in state 5 resolved as shift
WARNING: shift/reduce conflict for [ in state 5 resolved as shift
WARNING: shift/reduce conflict for LBB in state 5 resolved as shift
WARNING: shift/reduce conflict for + in state 5 resolved as shift
WARNING: shift/reduce conflict for - in state 5 resolved as shift
WARNING: shift/reduce conflict for * in state 5 resolved as shift
WARNING: shift/reduce conflict for POWER in state 5 resolved as shift
WARNING: shift/reduce conflict for MOD in state 5 resolved as shift
WARNING: shift/reduce conflict for INT_DIV in state 5 resolved as shift
WARNING: shift/reduce conflict for / in state 5 resolved as shift
WARNING: shift/reduce conflict for : in state 5 resolved as shift
WARNING: shift/reduce conflict for ~ in state 5 resolved as shift
WARNING: shift/reduce conflict for ? in state 5 resolved as shift
WARNING: shift/reduce conflict for LT in state 5 resolved as shift
WARNING: shift/reduce conflict for LE in state 5 resolved as shift
WARNING: shift/reduce conflict for EQ in state 5 resolved as shift
WARNING: shift/reduce conflict for NE in state 5 resolved as shift
WARNING: shift/reduce conflict for GE in state 5 resolved as shift
WARNING: shift/reduce conflict for GT in state 5 resolved as shift
WARNING: shift/reduce conflict for AND in state 5 resolved as shift
WARNING: shift/reduce conflict for OR in state 5 resolved as shift
WARNING: shift/reduce conflict for AND2 in state 5 resolved as shift
WARNING: shift/reduce conflict for OR2 in state 5 resolved as shift
WARNING: shift/reduce conflict for MATRIX_MULT in state 5 resolved as shift
WARNING: shift/reduce conflict for $ in state 5 resolved as shift
WARNING: shift/reduce conflict for @ in state 5 resolved as shift
WARNING: shift/reduce conflict for NLINE in state 32 resolved as shift
WARNING: shift/reduce conflict for NLINE in state 137 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 137 resolved as shift
WARNING: shift/reduce conflict for NLINE in state 145 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 145 resolved as shift
